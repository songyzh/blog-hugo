[{"content":"最近用G6做的一个图结构需求要做拖动范围限制，就是我们不希望用户可以把图完全拖出去画布，这样容易找不到造成困惑的局面，为了支持各种用户的拖动习惯，设计要求同时满足鼠标按键拖动和双指拖动。\n鼠标按键拖动很容易就能实现，因为G6有一些默认的全局自定义行为，可以根据需要来在生成G6对象的时候传入参数，当然也支持拖动范围的限制，配置如下：\n1 2 3 4 5 6 7 8  modes: { // 设置一些内置默认行为  [\u0026#39;default\u0026#39;]: [ { type: \u0026#39;drag-canvas\u0026#39;, scalableRange: -100,// 拖动 canvas 可扩展的范围，默认为 0  }, ...   对于scalableRange 的配置，可以看这里；文档中给出了比较好的图片解释；设置scalableRange -100，就可以是我们的图在画布中拖动时候始终保持100px 的内容保持在画布内；\n那么问题来了，没有双指拖动的默认行为怎么办？G6 提供了registerBehavior 可以注册自定义行为，在new G6ES.Graph 之前自定义一个行为，并且在上面的default 行为中添加成默认行为：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43  G6ES.registerBehavior(\u0026#39;double-finger-drag-canvas\u0026#39;, { getEvents: function getEvents() { return { wheel: \u0026#39;onWheel\u0026#39;, }; }, onWheel: (ev) =\u0026gt; { if (ev.ctrlKey) { // 按住ctrl 键滚轮缩放 这里也是考虑到了一些通用的用户习惯,于是我们保留了demo 中的这个操作  const canvas = graph.get(\u0026#39;canvas\u0026#39;); const point = canvas.getPointByClient(ev.clientX, ev.clientY); let ratio = graph.getZoom(); if (ev.wheelDelta \u0026gt; 0) { ratio += ratio * 0.05; } else { ratio -= ratio * 0.05; } graph.zoomTo(ratio, { x: point.x, y: point.y, }); config.setZoomValue(Math.floor(ratio * 100)); } else { // 双指拖动  const x = ev.deltaX || ev.movementX; const y = ev.deltaY || ev.movementY; graph.translate(-x, -y); } ev.preventDefault(); }, }); // default 行为中添加成默认行为 modes: { // 设置一些内置默认行为  [\u0026#39;default\u0026#39;]: [ { type: \u0026#39;drag-canvas\u0026#39;, scalableRange: -100,// 拖动 canvas 可扩展的范围，默认为 0  }, \u0026#39;double-finger-drag-canvas\u0026#39;, ...   终于实现了让人为难的双指移动需求，那么下一个问题来了，怎么实现限制范围？\n翻遍文档没有找到画布移动时候上下左右的位置信息接口，也就是说没有办法得到我们移动dom 元素时候能获得的元素的div.style.left 以及鼠标对象的clientX 等可以计算位置的信息，这就有点愁人了\u0026hellip;\u0026hellip;\n但是人家明明已经在鼠标拖动的时候实现了这个需求，于是我想的是，先看看能不能抄抄作业！都是基于这个图用的同一个坐标体系，说不定可以拿来借鉴，于是找到了项目源码中的 node_modules/@antv/g6/es/behavior/drag-canvas.js 文件 (我们的G6版本是4.0.1)，发现onMouseMove的时候会调用updateViewport方法，那么肯定是这个方法更新位置，在这个方法内打个断点：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38  updateViewport: function updateViewport(e) { debugger; var origin = this.origin; var clientX = +e.clientX; var clientY = +e.clientY; if (isNaN(clientX) || isNaN(clientY)) { return; } var dx = clientX - origin.x; // x 方向的位移  var dy = clientY - origin.y; // y 方向的位移  if (this.get(\u0026#39;direction\u0026#39;) === \u0026#39;x\u0026#39;) { // drag-canvas 中还有可能设置只有一个方向可以拖动  dy = 0; } else if (this.get(\u0026#39;direction\u0026#39;) === \u0026#39;y\u0026#39;) { dx = 0; } this.origin = { x: clientX, y: clientY }; var width = this.graph.get(\u0026#39;width\u0026#39;); var height = this.graph.get(\u0026#39;height\u0026#39;); var graphCanvasBBox = this.graph.get(\u0026#39;canvas\u0026#39;).getCanvasBBox(); // 传入的scalableRange 就在这里起作用！  if (graphCanvasBBox.minX \u0026lt;= width + this.scalableRange \u0026amp;\u0026amp; graphCanvasBBox.minX + dx \u0026gt; width + this.scalableRange || graphCanvasBBox.maxX + this.scalableRange \u0026gt;= 0 \u0026amp;\u0026amp; graphCanvasBBox.maxX + this.scalableRange + dx \u0026lt; 0) { dx = 0; } if (graphCanvasBBox.minY \u0026lt;= height + this.scalableRange \u0026amp;\u0026amp; graphCanvasBBox.minY + dy \u0026gt; height + this.scalableRange || graphCanvasBBox.maxY + this.scalableRange \u0026gt;= 0 \u0026amp;\u0026amp; graphCanvasBBox.maxY + this.scalableRange + dy \u0026lt; 0) { dy = 0; } this.graph.translate(dx, dy); },   终于，在graphCanvasBBox 这个变量中我们获得了想要的变量！！！好了，实现这个需求没有问题了！\n接下来当然是写一个我们自己的范围限制函数，首先道理和我们限制Dom元素移动的时候位置判断是一样的，这里用一个简图来表示一下4个方向的临界点：\n也就是说通过minX，maxX,minY,maxY 和宽高的关系就可以判断出当前图画在画布的位置，经过调试发现跟上面的updateViewport方法不同的是他提供的onWheel 方法回调中直接就能拿到跟移动之前的相对位移，不需要根据\nclientX - origin.x 来计算，于是经过几次调试终于得到了我们的updateViewport 方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45  let scalableRange = -100; // 自己定义一个范围限制 onWheel: (ev) =\u0026gt; { if (ev.ctrlKey) { // 按住ctrl 键滚轮缩放  const canvas = graph.get(\u0026#39;canvas\u0026#39;); const point = canvas.getPointByClient(ev.clientX, ev.clientY); let ratio = graph.getZoom(); if (ev.wheelDelta \u0026gt; 0) { ratio += ratio * 0.05; } else { ratio -= ratio * 0.05; } graph.zoomTo(ratio, { x: point.x, y: point.y, }); config.setZoomValue(Math.floor(ratio * 100)); } else { // 这里是双指异动 + 范围限制  let dx = ev.deltaX || ev.movementX; let dy = ev.deltaY || ev.movementY; let width = this.instance.get(\u0026#39;width\u0026#39;); let height = this.instance.get(\u0026#39;height\u0026#39;); let graphCanvasBBox = this.instance.get(\u0026#39;canvas\u0026#39;).getCanvasBBox(); if ( (graphCanvasBBox.minX \u0026lt;= width + scalableRange \u0026amp;\u0026amp; graphCanvasBBox.minX - dx \u0026gt; width + scalableRange) || (graphCanvasBBox.maxX + scalableRange \u0026gt;= 0 \u0026amp;\u0026amp; graphCanvasBBox.maxX + scalableRange - dx \u0026lt; 0) ) { dx = 0; } if ( (graphCanvasBBox.minY \u0026lt;= height + scalableRange \u0026amp;\u0026amp; graphCanvasBBox.minY - dy \u0026gt; height + scalableRange) || (graphCanvasBBox.maxY + scalableRange \u0026gt;= 0 \u0026amp;\u0026amp; graphCanvasBBox.maxY + scalableRange - dy \u0026lt; 0) ) { dy = 0; } // eslint-disable-next-line no-use-before-define  graph.translate(-dx, -dy); } ev.preventDefault(); },   好了这个需求完成了～\n从这个需求得到的经验就是，如果需要实现一个类似的需求，但是没有直接的方法和API,可以去他已经实现的代码借鉴，会有一些踩坑的过程，但是因为有之前的写过的拖动DOM 的需求经验，所以大概能很快找到他在这里的实现思路，算是一种经验和推理的产物吧～\n参考的主要是G6 的官方文档：https://g6.antv.vision/zh/docs/manual/advanced/coordinate-system\n","description":"","id":2,"section":"posts","tags":["前端"],"title":"G6中实现双指拖动范围限制","uri":"https://blog.syzh.fun/posts/hxd/g6-drag/"},{"content":"一 问题： 我们都知道在js 中一个重要的数据类型就是引用数据类型，特征就是相同的引用类型值可以在各个地方被改变： 1 2 3 4 5  var objA = {name: \u0026#39;Alice\u0026#39;}; var objB = objA; objB.name = \u0026#34;Bob\u0026#34;; console.log(objA.name); // \u0026#34;Bob\u0026#34; console.log(objB.name); // \u0026#34;Bob\u0026#34;   ​ 上面的简易代码显示了引用类型的这一特征。这个特征在多个页面结构引用同一个数据的时候很方便，但这种公共状态数据可以随意修改也带来的代码的不稳定性和难以维护。没有人知道会有谁在不经意的情况下修改了你们公共的状态数据。今天我们不谈redux这一个通用的前端框架数据流解决方案，只谈谈细粒度更小的不可变数据的实现。\n​ 我们都知道react 的实现中，数据变化导致页面重新更新Dom 主要是靠setState方法改变组件内的state,调用了setState 方法后就会更新视图，那么当我们setState 改变的属性页面中没有用到的时候，或者传入的属性就是当前的值，setState 会有优化吗？这里做两个demo 来检测一下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  // 这里使用crate-react-app 的框架，改变其中的app.js import React from \u0026#39;react\u0026#39;; class App extends React.Component { constructor(props) { super(props); this.state = { list: [{ todo: \u0026#39;learn typescript\u0026#39;, }] } } componentDidMount() { setInterval(() =\u0026gt; { this.setState({ list: this.state.list, // 值没有改变  }) }, 2000); } render() { console.log(\u0026#39;render called\u0026#39;); // 这里会一直打印，说明相同的值不会被检测到  let content = this.state.list.map((item) =\u0026gt; { return \u0026lt;p\u0026gt;{item.todo}\u0026lt;/p \u0026gt; }); return content; } } export default App;   同样的，没有使用的state 属性也会一直导致重新render:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  import React from \u0026#39;react\u0026#39;; class App extends React.Component { constructor(props) { super(props); this.state = { list: [{ todo: \u0026#39;learn typescript\u0026#39;, }] } } componentDidMount() { setInterval(() =\u0026gt; { this.setState({ notUsed: \u0026#39;this is a not used property\u0026#39;, // 没有在页面中使用到的值  }) }, 2000); } render() { console.log(\u0026#39;render called\u0026#39;); // 这里会一直打印  let content = this.state.list.map((item) =\u0026gt; { return \u0026lt;p\u0026gt;{item.todo}\u0026lt;/p \u0026gt; }); return content; } } export default App;   当然，在项目中我们一般不会这样做，使用没有用到的state属性或者传入相同的值，但是两个例子让我们知道，不能完全依赖setState 来构建我们的交互，毕竟渲染Dom 节点是很消耗性能的，复杂的页面和逻辑中需要考虑到这个过程的优化，避免不必要的渲染。\n二 之前的解决方案：官网中指出了集中优化方案，使用shouldComponentUpdate 来自定义是否需要重新渲染的逻辑： 1 2 3 4 5 6 7 8 9 10 11 12  shouldComponentUpdate(nextProps, nextState) { // todo 这里可以加上对新老 props state 的比较来决定是否需要更新组件  return true; } // 加上这里的判断就不会一直重复渲染，因为两个list 是同一个引用  shouldComponentUpdate(nextProps, nextState) { if (nextState.list === this.state.list) { return false; } return true; }   ​ React.PureComponent 就是基于这一程序帮你写好了新旧props state 的对比，但是他对比的是新老\nprops state的浅比较，对于复杂数据结构就判断不出来变化了。\n​ 或者我们也可以使用es6 的结构赋值，或者Object.assign，或者利用数组的concat，JSON.Stringify 等一切能够基于原来数据产生互不干扰的新数据的方法，比如在我们的项目中在对state中复杂数据的遍历处理前，为了不产生意料之外的副作用，我们会使用lodash 的 cloneDeep，基于这个新数据进行处理判断：\n1 2 3 4 5  let workerList = _cloneDeep(this.state.list); workerList.forEach((element) =\u0026gt; { // todo ...  }); this.setState({ list: workerList });   归根结底，对于state 中的这个list ,直接遍历修改是非常不美观，不符合react 设计流程的，也会引起代码的不好阅读和困惑，明明人家提供的、建议的是setState 为何要直接修改这个引用类型的状态呢？\n三 开始使用immer 对于不可变数据的需求，终于引出了今天想来说一说的immer，相对于API更加丰富的Immutablejs,immer 似乎上手成本更低，接下来引入immer:\n1  npm install immer   index.js:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36  import produce from \u0026#34;immer\u0026#34; const baseState = [ { todo: \u0026#34;Learn typescript\u0026#34;, done: true }, { todo: \u0026#34;Try immer\u0026#34;, done: false } ] // immer 中主要使用produce方法来基于原来的数据生成新的immutable数据 const nextState = produce(baseState, draftState =\u0026gt; { // 这里的draftState 可以理解成baseState 的一个浅引用  // 注意这个函数里操作的只是draftState  draftState.push({todo: \u0026#34;Tweet about it\u0026#34;}); draftState[1].done = true; }); console.log(JSON.stringify(baseState)); // 可以看到原数据不受影响 // [{\u0026#34;todo\u0026#34;:\u0026#34;Learn typescript\u0026#34;,\u0026#34;done\u0026#34;:true},{\u0026#34;todo\u0026#34;:\u0026#34;Try immer\u0026#34;,\u0026#34;done\u0026#34;:false}]  console.log(JSON.stringify(nextState)); // 新增的数据在原数据基础上作出produce第二个函数中的变更 // [{\u0026#34;todo\u0026#34;:\u0026#34;Learn typescript\u0026#34;,\u0026#34;done\u0026#34;:true},{\u0026#34;todo\u0026#34;:\u0026#34;Try immer\u0026#34;,\u0026#34;done\u0026#34;:true},{\u0026#34;todo\u0026#34;:\u0026#34;Tweet about it\u0026#34;}]  console.log(baseState === nextState); // false 新旧对象并不相等  console.log(baseState[0] === nextState[0]); // true // 神奇的是没有变更的数据还是原来的数据！这肯定比上面粗暴的deepClone 在处理大数据的时候性能高，因为他是只修改了变化的部分 console.log(baseState[1] === nextState[1]); // false    因此上面的deepClone 可以替换成:\n1 2 3 4  let workerList = produce(this.state.list,(draft)=\u0026gt;{ // todo...对draft的操作 再也不用担心大数据deepClone的性能消耗  }) this.setState({ list: workerList });   当我们给produce 传递的第一个参数是函数，就是用于产生一个科里化函数，在官网可以看到更多例子，immer 基于原对象产生新对象的功能也使得他可以更便利的编写reducer,感兴趣的可以去看看。\n四 什么魔法造成了神奇的draft操作函数 ​ 秘诀就是proxy 代理，vue3.0 为了解决Object.defineProperty 的性能和不能为新增属性写代理的问题就采用了Proxy，Proxy 实际上重载（overload）了点运算符，即用自己的定义覆盖了语言的原始定义：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  var obj = new Proxy({}, { get: function (target, key, receiver) { console.log(`getting ${key}!`); return Reflect.get(target, key, receiver); }, set: function (target, key, value, receiver) { console.log(`setting ${key}!`); return Reflect.set(target, key, value, receiver); } }); obj.count = 1 // setting count! ++obj.count // getting count! // setting count! // 2   在produce方法中的draft 就是这样的一个代理，当我们设置值的时候，会走immer中定义好的set,获取值的时候也是同理。 produce(base, recipe, patchListener) ，produce 接收三个参数，正常来说 base 是原数据，recipe 是用户执行修改逻辑的地方，patchListener 是用户接收 patch 数据然后做一些自定义操作的地方，patchListener 我暂时没有用到过。\n 调用createProxy生成 draft 供用户使用，createProxy就是生成上面的代理 执行用户传入的 recipe，拦截读写操作，走到 proxy 内部的 getter/setter 调用processResult解析组装最后的结果返回给用户  在每一个对象中还定义了modified 属性来标记是否被更改过，如果取值的时候发现modified为false，则直接返回原来的值（proxy中的）。\n具体的代码在这个架构上更加细致和繁琐，在这里不多赘述。\n全文完。\n参考文档：\nhttps://zh-hans.reactjs.org/docs/optimizing-performance.html\nhttps://immerjs.github.io/immer/docs/introduction\nhttps://juejin.cn/post/6844903782145327118\nhttps://zhuanlan.zhihu.com/p/34691516\n","description":"","id":3,"section":"posts","tags":["前端"],"title":"react不可变数据之immer的使用","uri":"https://blog.syzh.fun/posts/hxd/react-immer/"},{"content":"在最近的工作中涉及到了页面大数量的计算和渲染，因为没能很好的利用浏览器开发工具中的perfomance，导致上线后性能遭到了一些吐槽，好在及时通过performance profiling 的过程发现了瓶颈所在，这篇文章就是对于谷歌开发工具官网中的教程evaluate-performance的一次翻译和学习。\n教程是Chrome 59，我本地安装的是86，可能会有一些差异。\nget started 1 无痕模式 打开一个浏览器窗口（⌘ + Shift + n），无痕模式确保浏览器在一个比较干净的状态下运行，比如说你安装了一些插件，那么这些插件可能会影响你测量性能时候的指标；\n2 无痕窗口中打开下面的网址，这就是你将要profile分析的网页，网页中有很多上下移动的方块；\n1  https://googlechrome.github.io/devtools-samples/jank/   3 输入 Command+Option+I (Mac) or Control+Shift+I (Windows, Linux) 命令打开 DevTools.\nsimulate a mobile cpu 手机相较于台式和笔记本电脑有相对弱一些的中央处理器，当我们分析一个网页的时候，可以使用CPU Throttling 来模拟手机页面效果。\n1 DevTools中点击performan 栏；\n2 确保勾选了Screenshots；\n2 点击performace下的设置，DevTools显示出它如何捕获性能指标相关的设置；\n3 这里我选择4x slowdown 来限制cpu 效率是通常4倍的慢速\nSet up the demo 要创建一个让所有读者都看到相同性能分析效果的demo不太容易，这部分能让你定制自己的demo来确保能看到和教程类似的运行结果。\n1 点击Add 10 直到蓝色方块明显异动的比之前更慢，高配的机器可能需要20次；\n2 点击Optimize，蓝色方块应该会明显移动更快和顺畅；\n3 点击Un-Optimize，蓝色方框应该再次移动的慢且卡顿。\nRecord runtime performance 当你点击页面的优化版本时，蓝色方块移动更快，原因是什么？两个版本都应该在相同的距离和时间里移动每一个方块，这里用performance 录一段分析资料来分析没有优化时页面的性能瓶颈。\n1 点击浏览器performance 中的 Record ，devtools 会抓取页面运行时候的性能指标；\n2 等待几秒\n3 点击Stop，devtools停止记录，处理数据，然后把结果展示在p er formance 面板里\nAnalyze the results 得到一份性能记录之后，就可以判断当前页面的性能好坏，得到不好的原因。\nAnalyze frames per second 分析一个页面动画性能的主要指标就是FPS(帧率)，用户们普遍都在帧率时60 的时候比较满意（也就是每秒页面刷新60次）\n1 看看我们的FPS 图表，当你看到FPS 上的红条时，说明帧率已经降到了会影响到用户体验的程度，通常来说，绿条越高说明帧率越高；\n2 在FPS 下面还能看到cpu 图表，CPU 图中颜色对应着最下面的summary 图标的颜色，事实是，CPU图表充满了颜色，意味着CPU在录音期间达到了极限。每当你看到CPU长时间超负荷工作时，就暗示着你要想办法让它减少工作量。\n3 将鼠标悬浮在FPS, CPU, 或者 NET 上面， DevTool会展示当前页面的内容，将鼠标从左往右移动可以看到录制时候的页面动态情况，这就叫scrubbing（擦洗？这块我也不太理解是个啥意思），这对手动分析动画过程非常有用。\n4 在Frames 部分，鼠标悬浮在一个绿色方块上可以看到当时那一帧的帧率（FPS）,每帧可能都低于60帧/秒的目标。(原来以为是我的谷歌版本较新，没有悬浮展示帧率的效果，后来发现是可以将下面的js heap - GPU 那一行右侧往下拖，然后就可以看到了)\n通过这个演示，很明显页面的性能不是很好。但是在真实的场景中，它可能不是那么清楚，所以拥有所有这些工具来进行测量是很方便的。\nBonus: Open the FPS meter 另一个好用的工具就是FPS meter，可以实时提供当前页面的帧率，\n1 用Command+Shift+P (Mac) 或者 Control+Shift+P (Windows, Linux) 打开菜单栏；\n2 输入rendering,找到show frames per second \u0026hellip;,点击选中，然后就可以看到页面上的实时帧率\n3 关闭也是1步骤，然后选项就是 hide frames per second \u0026hellip;\n这里我的操作和文中的显示的图不一样，查阅了一些没查出原因。。。esc 也并不能退出\n文中的效果：\n我的效果：\n不知为何显出这一堆数字而不是fps..数字还有重叠\u0026hellip;\nFind the bottleneck 现在已经衡量和确定了当前的动画效果是有问题的，接下来就找一下原因。\n1 注意到summary 栏中，当没有选中某个事件的时候给出了所有活动的一个拆分时间。这个页面主要的时间都用到了rendering,既然性能优化就是一门做更少事情的艺术，我们的目标就是减少rendering 的工作所占用的时间；\n2 打开Main 这一栏，DevTools向你展示了主线程随时间变化的活动火焰图。x轴代表记录时间，每块方块代表一个事件。方块越宽意味着事件耗时比较长，y轴表示调用堆栈。当你看到堆栈堆积在一起时，这意味着上面的事件导致了下面的事件；\n3 记录里有很多数据。通过在上面总览部分单击、按住并拖动鼠标来放大单个动画帧所触发的事件，总览是包含FPS、CPU和NET图表的部分。Main部分和Summary选项卡仅显示记录的选定部分的信息（上图中有选中部分）。\n4 注意到Animation Frame Fired事件右上角的红色三角形，当看到这个红色三角形的时候，意味着这个事件可能又一些问题；\n5 点击Animation Frame Fired 事件，Summary 栏会给出这个事件的信息。注意到下面的reveal 链接，点击这个链接，DevTools 会高亮显示触发 Animation Frame Fired 事件的原因，注意到app.js:94链接，点击可以进入源码行；\n6 在 app.update 事件下面可以看到很多紫色的事件，如果它们更宽一些的话，看起来每个紫色块右上角都有又个红色三角形，现在点击一个紫色的 Layout事件，下面的DevTools会给出这个事件的详情，事实上，这里有一个关于强制回流(布局的另一种说法)的警告。\n7 点击上图的Summary栏中的app.js:70,可以看到强制回流的那一行代码：\n至此我们找到了原因（Figure 13）：\n代码的原因是，每一帧的动画中都改变了每一个方块的style属性，然后立刻访问每个方块在页面中的位置，因为上面刚刚改变了方块的style 属性，浏览器不知道是否每个方块的位置发生了变化，所以不得不进行重排来计算方块的位置，这里查看如何避免页面同步重新布局\nBonus: Analyze the optimized version 使用上面学习的过程和工具，点击示例页面中的Optimize，然后在进行一次录制，分析结果，从提高的帧率到减少主部分火焰图中的事件，你可以看到优化版本的应用做了更少的工作，得到了更好的性能。\n下面是一些优化页面的链接这里就不多说了，over。\n","description":"","id":4,"section":"posts","tags":["前端"],"title":"浏览器performance性能优化","uri":"https://blog.syzh.fun/posts/hxd/evaluate-performance/"},{"content":"vue3.0已经正式发布了，作为曾经vue2.0的用户当然迫不及待要来认识一下，趁假期有时间赶紧来小试牛刀～\n在查看文档和一些demo的过程中发现一下午想掌握所有新货有点好高骛远了，那么就从3.0中备受瞩目也是最常会用到的composition-api 来开始吧。\ncomposition-api 提出的原因是，在vue组件的逻辑中，我们原来的options api 是主张在组件内，根据逻辑来将代码写到对应的位置的，就是如下的结构\n1 2 3 4 5 6 7 8 9 10 11  export default { data () { return {} }, methods: {}, computed: {}, watch: {} }   在这种结构中，随着组件逻辑更加复杂，零落在各个参数中的函数/逻辑 复用困难，且无法和组件的生命周期结合，于是vue3.0 提出了composition-api，可以提取代码逻辑到一个单独的、可以利用生命周期函数的函数中来达到充分的逻辑复用，使我们的代码可以更加灵活的组合。\n首先根据官网的安装指导来安装最新版本的vue，然后尝试做一个简易的todo list，要使用composition-api ，意味着我们的组件中不再有data,methods等2.0中的结构，setup函数是composition-api 的入口点，在组件初始化props 和beforeCreate 之间执行一次，setup返回的内容可以直接在组件中使用，那么如何达到数据变化页面更新的效果呢？答案就是在setup中使用vue 提供的各种composition-api 来达到这种目的。\n我想实现可以添加待做事项，以及勾选事项代表该项已经做完，并且分别展示待做和已做列表，代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63  \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;div\u0026gt; \u0026lt;input placeholder=\u0026#34;输入待办\u0026#34; type=\u0026#34;text\u0026#34; :value=\u0026#34;todoText\u0026#34; @input=\u0026#34;($event)=\u0026gt;{todoText = $event.target.value}\u0026#34;\u0026gt; \u0026lt;button @click=\u0026#34;addItem\u0026#34;\u0026gt;添加\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;p\u0026gt;待办事项：\u0026lt;/p \u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li v-for=\u0026#34;(item,i) in tobeDone\u0026#34; :key=\u0026#34;item.text\u0026#34; @click=\u0026#34;checkItem(item,i)\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;checkbox\u0026#34; name=\u0026#34;item.text\u0026#34; value=\u0026#34;item.text\u0026#34;\u0026gt;{{item.text}}\u0026lt;br\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;p\u0026gt;已办完：\u0026lt;/p \u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li v-for=\u0026#34;(item) in haveDone\u0026#34; :key=\u0026#34;item.text\u0026#34; \u0026gt; \u0026lt;span\u0026gt;{{item.text}}\u0026lt;/span\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import { ref, reactive, computed } from \u0026#39;vue\u0026#39; export default { name: \u0026#39;App\u0026#39;, setup() { let todoText = ref(\u0026#39;\u0026#39;); // 返回 {value:\u0026#39;\u0026#39;} 适用于简单双向绑定数据 defineproperty 实现  let todoItems = reactive({list:[]}); // 适用于复杂引用类型双向绑定数据 proxy代理实现  function addItem() { // state 0 未做 1 已做  todoItems.list.push({text:todoText.value,state:0}); todoText.value = \u0026#39;\u0026#39;; } function checkItem(item) { item.state = item.state=== 0? 1 : 0; } // composition api 中的computed  // 筛选已做好的  let haveDone = computed(()=\u0026gt;{ return todoItems.list.filter(item =\u0026gt; item.state === 1); }) // 筛选未做好的  let tobeDone = computed(()=\u0026gt;{ return todoItems.list.filter(item =\u0026gt; item.state === 0); }) return { // 返回的内容在组件中都可以直接拿到,不反回会在template中引用时候报错  todoItems, addItem, todoText, checkItem, haveDone, tobeDone } } } \u0026lt;/script\u0026gt;   完成效果如下：\n从以上代码中可以看出，在vue3.0 中的组件中，使用composition-api 后逻辑主要集中在setup 中，这不禁让人觉得setup 中的代码不会过于臃肿和复杂吗？当然不会，在实际应用场景中，我们有很多拉取接口数据和在生命周期中某个阶段需要有一些动作的场景，这些都可以从setup 函数中抽离出来形成一个独立的js 模块提供封装好的某一部分逻辑，这些在官方指导中都有更多的示例和说明。\n总体来说，在做这个demo的过程中，感觉到在应用到vue3.0的时候需要对每一个点去新文档中确认是否有变化，比如这里的v-model 就跟原来的用法有变化，直接用2.0还是无法与composition api 相适应的。另外，整体看来似乎跟react中的函数式组件+钩子函数有一些相似的用法，在编写组件的过程更多的是考虑数据的变化，生命周期函数只是完成功能的一个辅助力量，不像之前在编写组件的过程主线是vue实例的生命周期过程，另外，vue3.0 也提供了更多针对数据的api,例如isRef,isReadonly,isProxy 等等，对不同的场景使用不同的数据处理方式可以得到更好的组件性能。\n参考：\nhttps://vue3js.cn/docs/zh/guide/installation.html\nhttps://vue3js.cn/docs/zh/guide/composition-api-introduction.html#%E4%BB%80%E4%B9%88%E6%98%AF-composition-api\n","description":"","id":5,"section":"posts","tags":["前端","vue-3.0"],"title":"vue3.0的Composition-API","uri":"https://blog.syzh.fun/posts/hxd/vue-3.0-composition-api/"},{"content":"前言 ​ 我们都知道，在用react开发前端应用时，有类组件和函数组件两种形式来编写组件，其中函数组件有自己的状态state，每次调用setState 都会有一个更新组件需求添加到队列中，从而实现页面跟随数据变化而更新。随着前端生态的发展，React 16.8 引入hook 的概念，可以让我们在编写相对于类组件更加轻便灵活的函数式组件的同时，也能拥有组件内部的状态（useState）、生命周期函数（useEffect）等类组件的特性。本文就部分钩子的作用和实现做一些总结和探讨。\n一 最常使用的useState 首先将官网的demo拿过来：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  import React, { useState } from \u0026#39;react\u0026#39;; function Example() { // 声明一个叫 \u0026#34;count\u0026#34; 的 state 变量  const [count, setCount] = useState(0); return ( \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;You clicked {count} times\u0026lt;/p \u0026gt; \u0026lt;button onClick={() =\u0026gt; setCount(count + 1)}\u0026gt; Click me \u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); }   useState 实现了：\n 传入一个state 初始变量 返回state引用和改变state的回调 如果state改变 更新组件  在我们理解函数组件的时候，本质上它是一个函数，每当组件更新，就会重新执行一遍函数，如果函数内正常声明的变量，都是会重新声明一遍，跟上一次函数的执行时声明的变量毫无关系，那么如果我们想要每次执行函数时能有一个变量始终基于上一次函数执行后的结果上再更改，就只有一个办法： 在函数外声明一个变量，又因为我们需要监听状态变化来重新渲染，所以需要将更改状态的操作抽离到一个函数中，由此可以在更改状态后添加更新一以及其他一些逻辑，实现一个自己的setState:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43  import React from \u0026#39;react\u0026#39;; import ReactDOM from \u0026#39;react-dom\u0026#39;; // hook 相关的变量存储 let hook = { memoizedState: null, } function useState(initialState) { // 这里也可以添加对initialState 是否是函数的判断来支持 react惰性初始 state  // 也就是initialState 如果是函数，执行函数返回结果作为initialState  hook.memoizedState = hook.memoizedState || initialState; function setState(state) { hook.memoizedState = state; // 由于源码中这里关联fiber，简化它门的dispatch重新渲染的逻辑  render(); // state 变化重新渲染  } return [hook.memoizedState, setState]; // 返回数组便于用户解构和重命名 } function Example() { // 声明一个叫 \u0026#34;count\u0026#34; 的 state 变量  const [count, setCount] = useState(0); return ( \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;You clicked {count} times\u0026lt;/p \u0026gt; \u0026lt;button onClick={() =\u0026gt; setCount(count + 1)}\u0026gt; Click me \u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } function render(){ ReactDOM.render( \u0026lt;Example/\u0026gt;, document.getElementById(\u0026#39;root\u0026#39;) ); } render();   二 第二常用的useEffect useEffect 实现了：\n 默认情况下，effect 将在每轮渲染结束后执行（没有依赖） 组件更新后如果依赖的变量数组有变化，执行回调 （有依赖项）  同理，要想比较两次函数中声明的变量是否相同，需要在函数外声明缓存变量来比较，由于是依赖数组，需要有一个循环依次比较数组的每一项：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62  import React, { useState } from \u0026#39;react\u0026#39;; import ReactDOM from \u0026#39;react-dom\u0026#39;; // hook 相关的变量存储 // 这里为方便演示，只有一个lastDeps，真实场景中应该为每一次useEffect 分配一个lastDeps/destroy let hook = { lastDeps: null, destroy: null // useEffect 返回的销毁函数 } function useEffect(create,deps) { if (!hook.lastDeps) { // 第一次渲染  hook.destroy = create(); // 缓存useEffect的清除函数  hook.lastDeps = deps; } else { let isSame = hook.lastDeps.every((item,index) =\u0026gt; { return item === deps[index]; }); if (!isSame) { hook.destroy(); // 在执行新的回调前先执行清除函数  hook.destroy = create(); hook.lastDeps = deps; } } } function Example() { // 声明一个叫 \u0026#34;count\u0026#34; 的 state 变量  const [count, setCount] = useState(0); const [stable, setStable] = useState(2); // 依赖count 或者不添加依赖数组会导致每次组件更新都执行  useEffect(() =\u0026gt; { document.title = count; return ()=\u0026gt;{ console.log(\u0026#39;clear\u0026#39;); } },[count]) // 依赖一个不变化的变量只执行一次回调  // useEffect(() =\u0026gt; {  // console.log(\u0026#39;test\u0026#39;);  // },[stable])  return ( \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;You clicked {count} times\u0026lt;/p \u0026gt; \u0026lt;button onClick={() =\u0026gt; setCount(count + 1)}\u0026gt; Click me \u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } function render(){ ReactDOM.render( \u0026lt;Example/\u0026gt;, document.getElementById(\u0026#39;root\u0026#39;) ); } render();   以上的例子只是为了理解useEffect 原理而写的例子，在真实场景中，官网中指出：与 componentDidMount、componentDidUpdate 不同的是，在浏览器完成布局与绘制之后，传给 useEffect 的函数会延迟调用，官网还指出： 为防止内存泄漏，清除函数会在组件卸载前执行，所以在上面的例子中，create和destroy 函数的执行时机是不准确的，在react机制中应该是有更加复杂的调度。\n三 通常常用的useCallback 官网中的解释是把内联回调函数及依赖项数组作为参数传入 useCallback，它将返回该回调函数的 memoized 版本，该回调函数仅在某个依赖项改变时才会更新,当你把回调函数传递给经过优化的并使用引用相等性去避免非必要渲染（例如 shouldComponentUpdate）的子组件时,它将非常有用，当我们在函数组件中声明一个函数，那么每次执行渲染都会声明这个新的函数，如果此函数是传递给子组件的一个属性，那么每次函数更新都会传递给子组件全新的函数，在使用memo包装子组件的时候结合useCallback 可以有效减少子组件不必要的重新渲染：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79  import React, { useState ,memo} from \u0026#39;react\u0026#39;; import ReactDOM from \u0026#39;react-dom\u0026#39;; let hook = { lastCallback: null, lastDeps: null, } function useCallback(cb,deps) { if (!hook.lastCallback) { // 第一次渲染  hook.lastCallback = cb; hook.lastDeps = deps; return cb; } else { let isSame = hook.lastDeps.every((item,index) =\u0026gt; { return item === deps[index]; }) if (!isSame) { hook.lastCallback = cb; hook.lastDeps = deps; return cb; } else { return hook.lastCallback; } } } function Child(props) { console.log(\u0026#39;child render\u0026#39;); return ( \u0026lt;div\u0026gt; \u0026lt;br /\u0026gt; \u0026lt;span onClick={props.handleClick}\u0026gt; I am child\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; ) } Child=memo(Child); // memo 包装的组件在属性不变时不再重新渲染  function Example() { // 声明一个叫 \u0026#34;count\u0026#34; 的 state 变量  const [count, setCount] = useState(0); const [count2, setCount2] = useState(0); // 这样写每次传递给Child 组件的handleClick 都是全新的函数  // 点击add count2 -\u0026gt; 组件刷新 -\u0026gt;handleClick是新的函数 -\u0026gt;Child 组件props变化重新渲染  // let handleClick = () =\u0026gt; {  // setCount(count + 1);  // }  // 点击add count2 -\u0026gt; 组件刷新 -\u0026gt;handleClick是旧的函数 -\u0026gt;Child 组件不会重新渲染  let handleClick = useCallback(() =\u0026gt; { setCount(count + 1); },[count]) return ( \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;count {count}\u0026lt;/p \u0026gt; \u0026lt;button onClick={() =\u0026gt; setCount(count + 1)}\u0026gt; add count \u0026lt;/button\u0026gt; \u0026lt;br /\u0026gt; \u0026lt;p\u0026gt;count2 {count2}\u0026lt;/p \u0026gt; \u0026lt;button onClick={() =\u0026gt; setCount2(count2 + 1)}\u0026gt; add count2 \u0026lt;/button\u0026gt; \u0026lt;Child handleClick={handleClick}/\u0026gt; \u0026lt;/div\u0026gt; ); } function render(){ ReactDOM.render( \u0026lt;Example/\u0026gt;, document.getElementById(\u0026#39;root\u0026#39;) ); } render();   总结来说，优化都是靠函数外声明的变量来缓存值，并且在每次调用函数时做优化判断，在应用钩子函数的时候，要想达到理想的效果，需要尽可能理清在渲染过程的这些动作，避免引起更多bug 的情况。\n参考 https://zh-hans.reactjs.org/docs/hooks-state.html\n​ https://www.jianshu.com/p/61d6193e04da\n​ https://www.lagou.com/lgeduarticle/103675.html\n","description":"","id":6,"section":"posts","tags":["前端"],"title":"react-hooks 初探","uri":"https://blog.syzh.fun/posts/hxd/react-hooks-study/"},{"content":"一 问题背景 最近在使用G6 展示树状图的时候需要有导出图片的需求，于是使用graph.downloadFullImage 方法来导出canvas 内容到一个图片，在导出的过程中发现，如果树的内容量庞大，会出现导出的图片是0kb 的情况，本文就是对此问题的一个记录。\n二 尝试解决过程 首先找到了源码中graph.downloadFullImage 的位置，/node_modules/_@antv_g6@3.6.1@@antv/g6/es/graph/graph.js，在调用\ngraph.downloadFullImage 方法前设置断点，发现进入的是压缩后文件，原来package.json 中默认入口设置的是 \u0026ldquo;main\u0026rdquo;: \u0026ldquo;lib/index.js\u0026rdquo;,，为了可以进入源码调试，将引入G6 处修改：\n1 2  // import G6ES from \u0026#39;@antv/g6\u0026#39;; import G6ES from \u0026#39;@antv/g6/es/index\u0026#39;; // 调试源码走这里   再次调试可以进入未压缩的源码中。\n在调试过程中，发现不同的数据，在调用canvas.toDataURL 方法返回的内容不同，由此发现了出现问题的位置,下图分别展示了数量小和数据量大的时候调试到此处的情形,都是在node_modules/_@antv_g6@3.6.1@@antv/g6/es/graph/graph.js的downloadFullImage方法内\n发现了这个问题后，决定在本地代码中验证是否是这个原因，于是在方法中自己调用canvas.toDataURL 查看：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  // 省略部分react 组件代码 let [imgSrc,setImgSrc] = useState(\u0026#39;\u0026#39;); const handleMyExport = () =\u0026gt; { const canvas = document.getElementsByTagName(\u0026#39;canvas\u0026#39;)[0]; var dataURL = canvas.toDataURL(); console.log(dataURL); setImgSrc(dataURL); } return ( \u0026lt;div className=\u0026#34;App\u0026#34; \u0026gt; \u0026lt;button style={{position:\u0026#34;absolute\u0026#34;,top: 0,left: \u0026#39;110px\u0026#39;,zIndex: 999}} onClick={handleMyExport}\u0026gt;我的导出\u0026lt;/button\u0026gt; \u0026lt;div ref={ref}\u0026gt;\u0026lt;/div\u0026gt; \u0026lt; img src={imgSrc} alt=\u0026#39;\u0026#39; style={{position:\u0026#39;absolute\u0026#39;, top: \u0026#34;820px\u0026#34;}}/\u0026gt; \u0026lt;/div\u0026gt; );   在调试过程发现使用大量数据的时候，这里的canvas.toDataURL() 可以生成图片base64 编码，在img 标签中是可以展示图片内容的，这是什么原因？对比发现，这里的图片只展示的canvas 画布中的内容，远小于真正cavans 中大数据量需要展示的数据，downloadFullImage导出的图片是包括canvas 中不可见部分的内容的，由此可见是导出全图的大数量数据导致的0kb 问题。\n继续查看downloadFullImage 方法，发现他在导出全图的过程是通过生成一个新canvas 标签（new GCanvas(canvasOptions); 宽高是canvas 全部内容的宽高），不是在当前graph 所拥有的canvas 标签上导出的，以下摘出downloadFullImage 方法并添加部分注释\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71  /** * 导出包含全图的图片 * @param {String} name 图片的名称 * @param {String} type 图片类型，可选值：\u0026#34;image/png\u0026#34; | \u0026#34;image/jpeg\u0026#34; | \u0026#34;image/webp\u0026#34; | \u0026#34;image/bmp\u0026#34; * @param {Object} imageConfig 图片配置项，包括背景色和上下左右的 padding */ Graph.prototype.downloadFullImage = function (name, type, imageConfig) { var _this = this; var bbox = this.get(\u0026#39;group\u0026#39;).getCanvasBBox(); // 获取画布的包围盒 包括不可见部分内容  var height = bbox.height; var width = bbox.width; var renderer = this.get(\u0026#39;renderer\u0026#39;); // canvas  var vContainerDOM = createDom(\u0026#39;\u0026lt;id=\u0026#34;virtual-image\u0026#34;\u0026gt;\u0026lt;/div\u0026gt;\u0026#39;); var backgroundColor = imageConfig ? imageConfig.backgroundColor : undefined; var padding = imageConfig ? imageConfig.padding : undefined; if (!padding) padding = [0, 0, 0, 0];else if (isNumber(padding)) padding = [padding, padding, padding, padding]; var vHeight = height + padding[0] + padding[2]; // 将要生成的canvas 高度  var vWidth = width + padding[1] + padding[3]; // 将要生成的canvas宽度  var canvasOptions = { container: vContainerDOM, height: vHeight, width: vWidth }; var vCanvas = renderer === \u0026#39;svg\u0026#39; ? new GSVGCanvas(canvasOptions) : new GCanvas(canvasOptions); var group = this.get(\u0026#39;group\u0026#39;); var vGroup = group.clone(); var matrix = clone(vGroup.getMatrix()); if (!matrix) matrix = [1, 0, 0, 0, 1, 0, 0, 0, 1]; var centerX = (bbox.maxX + bbox.minX) / 2; var centerY = (bbox.maxY + bbox.minY) / 2; mat3.translate(matrix, matrix, [-centerX, -centerY]); mat3.translate(matrix, matrix, [width / 2 + padding[3], height / 2 + padding[0]]); vGroup.resetMatrix(); vGroup.setMatrix(matrix); vCanvas.add(vGroup); var vCanvasEl = vCanvas.get(\u0026#39;el\u0026#39;); // 将要生成图片的canvas  if (!type) type = \u0026#39;image/png\u0026#39;; setTimeout(function () { var dataURL = \u0026#39;\u0026#39;; if (renderer === \u0026#39;svg\u0026#39;) { ... } else { var imageData = void 0; var context = vCanvasEl.getContext(\u0026#39;2d\u0026#39;); var compositeOperation = void 0; if (backgroundColor) { var pixelRatio = window.devicePixelRatio; imageData = context.getImageData(0, 0, vWidth * pixelRatio, vHeight * pixelRatio); compositeOperation = context.globalCompositeOperation; context.globalCompositeOperation = \u0026#34;destination-over\u0026#34;; context.fillStyle = backgroundColor; context.fillRect(0, 0, vWidth, vHeight); } dataURL = vCanvasEl.toDataURL(type); // 生成图片base64 编码  } // 生成a链接完成下载效果  var link = document.createElement(\u0026#39;a\u0026#39;); var fileName = (name || \u0026#39;graph\u0026#39;) + (renderer === \u0026#39;svg\u0026#39; ? \u0026#39;.svg\u0026#39; : \u0026#34;.\u0026#34; + type.split(\u0026#39;/\u0026#39;)[1]); _this.dataURLToImage(dataURL, renderer, link, fileName); var e = document.createEvent(\u0026#39;MouseEvents\u0026#39;); e.initEvent(\u0026#39;click\u0026#39;, false, false); link.dispatchEvent(e); }, 16); };   查看canvas 的 toDataURL 方法，发现指出\u0026rsquo;如果画布的高度或宽度是0，那么会返回字符串“data:,”。',再次调试，发现vCanvasEl 的宽度和高度都不为0:\n经查canvas 元素大小在各浏览器中都有限制，\n那么针对这个限制如何应用于我们的导出需求呢？以下是我的几种方案：\n1、 针对导出做限制，当大于我们的极限时，提醒用户当前图片太大，可以选择树结构的某一部分来导出。这个想法是基于我们导出图片的初衷的，初衷是为了让用户清晰的看出整个树结构，当我测试时导出的3.4M 的一张图已经大到每个节点都需要非常费力去放大才能看到，这与初衷相违背，不能为了导出而导出，产品需要考虑到这种情况通过交互去优化体验。\n2 、在一定范围内考虑通过scale 方法缩放后导出，在不影响导出图片的结构清晰的前提下。\n3 、还是非常想得到全图，就可以在downloadFullImage 方法的基础上，添加对图片宽高的判断和计算，比如将图片切割为上下左右4个部分，得到每个部分的canvas限制内的图片base64,上传到后端，由后端小伙伴拼接成一张图返回，此方法基于用canvas 实现截图功能，麻烦的是要根据当前canvas 的宽高来决定如何分割，总体上是可以实现的。\n以上，这个问题暂时告一段落。\n参考：\n  https://g6.antv.vision/zh/docs/api/Graph\n  https://stackoverflow.com/questions/43860035/canvas-todataurl-returns-data-when-canvas-width-height-is-too-large\n  https://blog.csdn.net/HuangsTing/article/details/106141263\n  ","description":"","id":7,"section":"posts","tags":["前端"],"title":"antv.G6 导出全图得到0 bytes 的问题","uri":"https://blog.syzh.fun/posts/hxd/antv-g6-export-pic-zero-bytes/"},{"content":"在最近一段时间的面试中，前端异步解决方案是一个高频面试题，在此做一个总结回顾。\n一、首先从概念上理解，什么是同步异步？ 同步和异步是从消息通知机制来区分：\n同步表示将任务按顺序一个接一个执行，在上一个没有执行完之前不会进行下一个，调用者会得到每个任务返回值\n异步代表当前的任务如果需要一些时间和资源，调用方会返回执行下一个任务，没有返回结果，等到合适的时机再通过回调/通知继续当前的任务。\n二、js 中的异步 1 回调函数 在工作流程中我们最常用的就是通过回调函数来完成异步需求，传入指定的回调函数，当某个条件下会自动调用，比如完成一个ajax 请求:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  const xhr = new XMLHttpRequest(); xhr.open(\u0026#39;GET\u0026#39;, \u0026#39;http://localhost:8080/\u0026#39;); xhr.onreadystatechange = () =\u0026gt; { if (xhr.readyState === 4) { if (xhr.status \u0026gt;= 200 \u0026amp;\u0026amp; xhr.status \u0026lt; 300) { const res = xhr.responseText; console.log(res) } else if (xhr.status \u0026gt;= 400) { console.log(\u0026#39;失败\u0026#39;); } } } xhr.send();   js 也提供一些api 来支持异步调用，用法都是传入一个回调函数，将在指定时间之后执行该函数，比如setTimeout,setInterval,requestAnimationFrame\n1 2 3 4 5 6 7 8 9 10 11 12  setTimeout(() =\u0026gt; { console.log(\u0026#39;1秒后打印\u0026#39;) }, 1000); setInterval(() =\u0026gt; { console.log(\u0026#39;隔1秒打印\u0026#39;) }, 1000); requestAnimationFrame(()=\u0026gt;{ console.log(\u0026#39;浏览器下一次重绘之前执行\u0026#39;) })   需要注意的是，在浏览器的事件循环中，并不会在精准的到达时间调用回调，还是考虑事件循环机制，当主线程代码执行完毕，才会去消息队列中查看是否有到达时间的回调，如果主线程因为一些大量运算导致时间到达的时候还没完成，那么定时器中的回调函数会在设定的时间基础上有延迟。\nnodejs 中的异步支持回调函数，并且规定异步API 回调函数的第一个参数是错误信息\n1 2 3 4 5  const fs = require(\u0026#39;fs\u0026#39;); fs.readFile(\u0026#39;./test.txt\u0026#39;,\u0026#39;utf8\u0026#39;,function (err,data) { console.log(\u0026#39;name\u0026#39;,data); })   发布订阅 发布订阅的思想是将即将执行的函数暂存，等需要的时候触发，例如\n1 2 3  document.getElementById(\u0026#34;myBtn\u0026#34;).addEventListener(\u0026#34;click\u0026#34;, function(){ document.getElementById(\u0026#34;demo\u0026#34;).innerHTML = \u0026#34;Hello World\u0026#34;; });   是将参数函数绑定到id 为myBtn的div click 事件队列中，当点击的时候触发这个函数，不过同理要走事件循环的逻辑。\n实现一个简易的发布订阅功能：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35  class myEvent{ constructor(){ this.events = {};// 存储事件  } // 添加监听  on(eventName,fn){ if(!this.events[eventName]){ this.events[eventName] = [fn]; }else { this.events[eventName].push(fn); } } // 触发监听  emit(eventName,...args){ console.log(this.events[eventName]); if(this.events[eventName]){ this.events[eventName].forEach(fn =\u0026gt; fn(...args)); } } } const evt = new myEvent(); evt.on(\u0026#39;click\u0026#39;,(...args)=\u0026gt;{ console.log(\u0026#39;click1\u0026#39;,...args); }) evt.on(\u0026#39;click\u0026#39;,()=\u0026gt;{ console.log(\u0026#39;click2\u0026#39;); }) setTimeout(() =\u0026gt; { evt.emit(\u0026#39;click\u0026#39;,\u0026#39;1\u0026#39;,\u0026#39;2\u0026#39;); }, 1000);   promise 随着项目复杂度增加，基于回调函数的异步方案会有一些问题，比如b接口需要a接口的数据后才能发送，这时代码就需要嵌套，如果是多个请求串行，代码可能会变成\n1 2 3 4 5 6 7 8 9 10  // 假设使用jquery封装好的ajax $.ajax({ url: \u0026#34;http://localhost:8080/a\u0026#34;, success: function(resA){ // todo...  $.ajax({ url: \u0026#34;http://localhost:8080/b\u0026#34;, success: function(resB){ // toto...  $.ajax({ url: \u0026#34;http://localhost:8080/c\u0026#34;, success: function(resC){ console.log(resC) }}); }}); }});   这样的多层嵌套看起来不美观且难以理解，错误处理也需要一层层判断，于是es6标准引入promise,\npromise 支持用户传入一个executor 函数，并提供resove和reject回调，用户可以方便的在executor 函数中调用来更改promise 内部状态，当状态改变，promise.then中传入的成功和失败回调就会被依次调用，then方法返回的是一个新的Promise实例,因此promise支持链式调用，提供catch方法统一捕获错误，上面的例子可以写成\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35  // 简易封装ajax 返回promise function myFetch(method,url){ return new Promise((resolve,reject)=\u0026gt;{ const xhr = new XMLHttpRequest(); xhr.open(method, url); xhr.onreadystatechange = () =\u0026gt; { if (xhr.readyState === 4) { if (xhr.status \u0026gt;= 200 \u0026amp;\u0026amp; xhr.status \u0026lt; 300) { const res = xhr.responseText; resolve(JSON.parse(res)) } else if (xhr.status \u0026gt;= 400) { reject(\u0026#39;error\u0026#39;+xhr.status) } } } xhr.send(); }) } const promise = myFetch(\u0026#39;get\u0026#39;,\u0026#39;http://localhost:8080/a\u0026#39;); .then((resA)=\u0026gt;{ // todo ...  return myFetch(\u0026#39;get\u0026#39;,\u0026#39;http://localhost:8080/b\u0026#39;); }) .then((resB)=\u0026gt;{ // todo...  return myFetch(\u0026#39;get\u0026#39;,\u0026#39;http://localhost:8080/c\u0026#39;); }) .then((resC)=\u0026gt;{ console.log(resC) }).catch((err)=\u0026gt;{ console.log(err) })   promise 还提供了all,race 等方法来完成并发请求，竞态请求功能，在具体的业务中都能得到很好的应用。\npromsie原理上也是基于回调函数来完成异步需求，promise 也有一些缺点，比如无法取消Promise，一旦新建它就会立即执行，无法中途取消。\ngenerator \u0026lsquo;*\u0026rsquo; 和 yield 组成了Generator函数，Generator 函数是 ES6 提供的一种异步编程解决方案，与通常的函数区别有二： 1 返回值是一个迭代器 2 函数遇到yield 关键字就暂停让出执行权 ，每次调用迭代器的next()方法都会得到一个包含value和done 的对象，\n1 2 3 4 5 6 7 8 9 10 11 12  function * gen(){ yield 1; yield 2; } let it = gen(); console.log(it.next()); console.log(it.next()); console.log(it.next()); // { value: 1, done: false } // { value: 2, done: false } // { value: undefined, done: true }   值得注意的是，for\u0026hellip;of循环，扩展运算符（\u0026hellip;）、解构赋值和Array.from方法内部调用的，都是遍历器接口。这意味着，它们都可以将 Generator 函数返回的 Iterator 对象，作为参数，不用逐个调用next方法就可以得到多个返回值结果\n摘取阮一峰教程中的例子\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  function* numbers () { yield 1 yield 2 } // 扩展运算符 [...numbers()] // [1, 2]  // Array.from 方法 Array.from(numbers()) // [1, 2]  // 解构赋值 let [x, y] = numbers(); x // 1 y // 2  // for...of 循环 for (let n of numbers()) { console.log(n) }   generator 函数迭代器和暂停的特征可以在代码中灵活的控制异步流程，尤其是结合promise,在每次next()后判断如果yield返回的是promise 对象，等待该promise执行返回结果，可以达到像同步代码一样编写异步代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  function async(num){ return new Promise((resolve,reject)=\u0026gt;{ setTimeout(() =\u0026gt; { resolve(num) }, 1000); }) } function* gen(params) { let res1 = yield async(100); let res2 = yield async(200); } const iterator = gen(); let {value,done} = iterator.next(); value.then((res)=\u0026gt;{ console.log(res); let {value,done} = iterator.next(); value.then((res)=\u0026gt;{ console.log(res) }) }) // 100 // 200    async函数 ES2017 标准引入了 async 函数，\nasync 函数是 Generator 函数的语法糖。也就是说，不必自己去一步步调用迭代器的next() 方法，它内部会在运行async 函数时候自动帮你运行，而且最后返回一个promise。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  // delay 效果 async function timeout(ms) { await new Promise((resolve) =\u0026gt; { setTimeout(resolve, ms); }); } async function asyncPrint(value, ms) { await timeout(ms); console.log(value); } console.log(asyncPrint(\u0026#39;hello world\u0026#39;, 1000)); // Promise { \u0026lt;pending\u0026gt; } 返回的是promise // hello world    使用注意点\n1、 async函数内部return语句返回的值，会成为返回的promise 的then方法回调函数的参数。\n2、async函数内部抛出错误，会导致返回的 Promise 对象变为reject状态。抛出的错误对象会被catch方法回调函数接收到。\n3、async函数返回的 Promise 对象，必须等到内部所有await命令后面的 Promise 对象执行完，才会发生状态改变，除非遇到return语句或者抛出错误。\n4、如果await后面的异步操作出错，那么等同于async函数返回的 Promise 对象被reject。\n最后，摘抄自动执行器的实现原理\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  function spawn(genF) { return new Promise(function(resolve, reject) { const gen = genF(); function step(nextF) { let next; try { next = nextF(); } catch(e) { return reject(e); } if(next.done) { return resolve(next.value); } Promise.resolve(next.value).then(function(v) { step(function() { return gen.next(v); }); }, function(e) { step(function() { return gen.throw(e); }); }); } step(function() { return gen.next(undefined); }); }); }   参考 怎样理解同步异步\nECMAScript 6 入门\n","description":"","id":8,"section":"posts","tags":["前端","JavaScript"],"title":"前端异步解决方案总结","uri":"https://blog.syzh.fun/posts/hxd/front-end-async-a9c14713e59f4677b6d2d9066b32f593/"},{"content":"  问题表现: 把slice传入函数并修改, 所做的append操作在函数外会丢失\n  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  func main() { // 初始化slice  s := make([]int, 0, 10) s = append(s, 1, 2, 3) // 打印当前slice的信息  header := (*reflect.SliceHeader)(unsafe.Pointer(\u0026amp;s)) fmt.Printf(\u0026#34;main start - %v, %#v\\n\u0026#34;, s, header) // 把slice传入函数  helper(s) // 打印当前slice的信息  header = (*reflect.SliceHeader)(unsafe.Pointer(\u0026amp;s)) fmt.Printf(\u0026#34;main end - %v, %#v\\n\u0026#34;, s, header) } func helper(s []int) { // 打印刚传入时slice的信息  header := (*reflect.SliceHeader)(unsafe.Pointer(\u0026amp;s)) fmt.Printf(\u0026#34;helper start - %v, %#v\\n\u0026#34;, s, header) // 向slice中插入数据  s = append(s, 4, 5) // 打印插入数据后slice的信息  header = (*reflect.SliceHeader)(unsafe.Pointer(\u0026amp;s)) fmt.Printf(\u0026#34;helper end - %v, %#v\\n\u0026#34;, s, header) } // ===================输出====================== // 可以看到, 即使slice的地址保持不变, 在helper函数中做的修改还是丢失了. main start - [1 2 3], \u0026amp;reflect.SliceHeader{Data:0xc00001c0a0, Len:3, Cap:10} helper start - [1 2 3], \u0026amp;reflect.SliceHeader{Data:0xc00001c0a0, Len:3, Cap:10} helper end - [1 2 3 4 5], \u0026amp;reflect.SliceHeader{Data:0xc00001c0a0, Len:5, Cap:10} main end - [1 2 3], \u0026amp;reflect.SliceHeader{Data:0xc00001c0a0, Len:3, Cap:10}       问题原因\n 因为golang总是传值, slice在传入helper函数后, helper函数中的s变量是一个新的变量, append操作修改的是此局部变量的Len值. 而main函数中的s变量, 其Len值始终没有改变. 这里需要注意, 如果在helper中修改了slice中的值, 比如s[0] = 100, 这个会反映在main函数中的s变量上. 因为两个s变量共用一个底层array    避免方式\n  如果想在函数中修改原始的slice, 可以传递引用, 或是返回新的slice. 传递引用的代码如下\n  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32  func main() { // 初始化slice  s := make([]int, 0, 10) s = append(s, 1, 2, 3) // 打印当前slice的信息  header := (*reflect.SliceHeader)(unsafe.Pointer(\u0026amp;s)) fmt.Printf(\u0026#34;main start - %v, %#v\\n\u0026#34;, s, header) // 把slice的引用传入函数  helper(\u0026amp;s) // 打印当前slice的信息  header = (*reflect.SliceHeader)(unsafe.Pointer(\u0026amp;s)) fmt.Printf(\u0026#34;main end - %v, %#v\\n\u0026#34;, s, header) } // 接收引用作为参数 func helper(s *[]int) { // 打印刚传入时slice的信息  header := (*reflect.SliceHeader)(unsafe.Pointer(s)) fmt.Printf(\u0026#34;helper start - %v, %#v\\n\u0026#34;, s, header) // 向slice中插入数据  *s = append(*s, 4, 5) // 打印插入数据后slice的信息  header = (*reflect.SliceHeader)(unsafe.Pointer(s)) fmt.Printf(\u0026#34;helper end - %v, %#v\\n\u0026#34;, s, header) } //==================输出===================== main start - [1 2 3], \u0026amp;reflect.SliceHeader{Data:0xc00001c0a0, Len:3, Cap:10} helper start - \u0026amp;[1 2 3], \u0026amp;reflect.SliceHeader{Data:0xc00001c0a0, Len:3, Cap:10} helper end - \u0026amp;[1 2 3 4 5], \u0026amp;reflect.SliceHeader{Data:0xc00001c0a0, Len:5, Cap:10} main end - [1 2 3 4 5], \u0026amp;reflect.SliceHeader{Data:0xc00001c0a0, Len:5, Cap:10} \u0026lt;!-- ``` --\u0026gt;       ","description":"","id":9,"section":"posts","tags":["后端","Golang","踩坑"],"title":"Golang踩坑总结-把slice传入函数","uri":"https://blog.syzh.fun/posts/syzh/golang-pitfall-slice-as-argument/"},{"content":"本文主要是对项目构建优化过程的记录，项目是基于vue3.0脚手架搭件的\n首次打包 dist : 15.1 M\n1 发现dist/img/icons 中有很多vue-cli 自带的vue-icon ，将pubic/img/icon 文件夹删除 ​ img中的favicon.icon 可以换成自己网站的favicon.icon(4k)\n​ 再次打包： 15M\n2 速度分析 我们的目的是优化打包速度，那肯定需要一个速度分析插件，此时 speed-measure-webpack-plugin 就派上用场了。它的作用如下：\n 分析整个打包总耗时 每个 plugin 和 loader 的耗时情况  首先，安装插件\n1  npm i -D speed-measure-webpack-plugin   然后修改 vue.config.js 配置文件\n1 2 3 4 5 6 7 8 9 10 11 12  // 导入速度分析插件 const SpeedMeasurePlugin = require(\u0026#34;speed-measure-webpack-plugin\u0026#34;); // 实例化插件 const smp = new SpeedMeasurePlugin(); module.exports = { configureWebpack: smp.wrap({ plugins: [ // 这里是自己项目里需要使用到的其他插件  // new yourOtherPlugin()  ] }) }   打包后总耗时 38.28 secs ，也可以看到各个loader 打包所耗费时间\n3 取消生产环境生成map文件 1  devtool: \u0026#39;#eval-source-map\u0026#39;,//映射js到原文件   由于打包后的js调试不方面，所以应用此，自动映射报错到原文件.\n看到生成的js文件件中有很多.js.map 文件，应该在生产环境去除，以加速生产环境构建，缩小体积\n1  productionSourceMap: false   再次打包： 25.93 secs dist 4.4M\n4 为了防止dist 目录文件越来越多，每次都要手动清楚dist 文件夹，比较麻烦 clean-webpack-plugin 默认每次打包前删除output.path 文件夹\n5 一直都有的warning 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  The following asset(s) exceed the recommended size limit (244 KiB). This can impact web performance. 以下文件超出了建议的大小 img/ionicons.a2c4a261.svg (542 KiB) css/chunk-vendors.d48681d6.css (583 KiB) js/chunk-vendors.7a36829a.js (1.8 MiB) js/main.42b88c10.js (527 KiB) entrypoint size limit: The following entrypoint(s) combined asset size exceeds the recommended limit (244 KiB). This can impact web performance. 入口文件以及相关的资源大小超过了建议的244k Entrypoints: app (2.41 MiB) ​ css/chunk-vendors.d48681d6.css ​ js/chunk-vendors.7a36829a.js ​ css/app.15a328ee.css ​ js/app.cbb3c76a.js   查看main.ts 觉得引入的内容过多，但是具体的打包情况不清楚，由此引入webpack-bundle-analyzer 插件来进行体积分析\n1  npm i -D webpack-bundle-analyzer   打包后可以看到node_modules 中的内容达到了5.43M,其他内容1.11M （未压缩）\n其中node_modules chunk-vendor.js 中最大的是elementui\n发现有很多动态加载的路由组件没有写明 webpackChunkName 导致单独打包了，而且其他动态加载的都叫main,导致打包的动态加载main.JS 过大\n优化： 将动态加载的模块根据功能块分为 order list user\n再次打包 没有过大的main.js 以及一些匿名的chunk ,打包时间18.69 secs 但还是有一些警告：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  asset size limit: The following asset(s) exceed the recommended size limit (244 KiB). This can impact web performance. Assets: img/ionicons.a2c4a261.svg (542 KiB) css/chunk-vendors.d48681d6.css (583 KiB) js/chunk-vendors.aefb80b0.js (1.8 MiB) js/list~order~user.7ae80867.js (396 KiB) warning entrypoint size limit: The following entrypoint(s) combined asset size exceeds the recommended limit (244 KiB). This can impact web performance. Entrypoints: app (2.41 MiB) ​ css/chunk-vendors.d48681d6.css ​ js/chunk-vendors.aefb80b0.js ​ css/app.15a328ee.css ​ js/app.a09ad1ae.js   警告是因为默认配置中提供了这些限制\nhttps://cli.vuejs.org/zh/guide/build-targets.html#%E5%BA%94%E7%94%A8 中给出了默认的打包策略\n@vue\\cli-service\\lib\\config\\prod.js 这里是cli中的默认配置，可以根据需要查看\n发现 第三方库会被分到一个独立包以便更好的缓存（也就是比较大的chunk-vendors.）,为了更快的加载，决定提取比较大的element\n在我们的项目中要引入很多的第三方组件库例如element-ui，还有公司内部的一些组件库，如果我们使用默认配置不做任何修改，vendors缓存组中的内容会很多，页面引用时耗时就会较长，所以将缓存组中的内容进行拆分是很有必要的。\n例如我们将element-ui分割成一个独立的chunk，cacheGroups中配置如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  configureWebpack: smp.wrap({ plugins: [ // 这里是自己项目里需要使用到的其他插件  // new yourOtherPlugin()  new CleanWebpackPlugin(), new BundleAnalyzerPlugin() ], optimization: { //注意这里要写到configureWebpack: smp.wra 内部  splitChunks: { cacheGroups:{ elementUI: { priority: 20, name: \u0026#34;elementUI\u0026#34;, test: /element-ui/, reuseExistingChunk: true, chunks: \u0026#39;initial\u0026#39; } } } } })   再次打包： 都在500k 之内，用时17.43 secs dist 4.4M 如果觉得不好，还可以继续抽取某个模块出来\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33  dist/js/chunk-vendors.f6665299.js 1187.85 KiB 410.17 KiB dist/js/elementUI.8d715862.js 651.54 KiB 161.19 KiB dist/js/list~order~user.7ae80867.js 396.42 KiB 109.46 KiB dist/js/list.4bae4c4a.js 73.11 KiB 20.93 KiB dist/js/order.d53d6a7b.js 56.50 KiB 11.95 KiB dist/js/user.960bd4f6.js 52.52 KiB 10.88 KiB dist/js/app.7a5d9e33.js 30.20 KiB 8.92 KiB dist/precache-manifest.b90139ea6a8765f 2.58 KiB 0.81 KiB 806da9c48a2db3e60.js dist/service-worker.js 0.95 KiB 0.54 KiB dist/css/chunk-vendors.2451089e.css 347.71 KiB 50.92 KiB dist/css/elementUI.cb02cf65.css 235.19 KiB 34.85 KiB dist/css/user.59bdb936.css 19.23 KiB 5.49 KiB dist/css/order.480f9cfb.css 18.01 KiB 2.18 KiB dist/css/list.752f1f66.css 17.29 KiB 2.54 KiB dist/css/app.15a328ee.css 11.20 KiB 5.32 KiB dist/css/list~order~user.c0f64a3d.css 4.94 KiB 1.06 KiB   关于打包结果的提示： 可以配置：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  module.exports = { //webpack配置  configureWebpack: { //关闭 webpack 的性能提示  performance: { hints:false } //或者 修改提示阙值  //警告 webpack 的性能提示  performance: { hints:\u0026#39;warning\u0026#39;, //入口起点的最大体积  maxEntrypointSize: 50000000, //生成文件的最大体积  maxAssetSize: 30000000, //只给出 js 文件的性能提示  assetFilter: function(assetFilename) { return assetFilename.endsWith(\u0026#39;.js\u0026#39;); } } }   6 尝试用compression-webpack-plugin 对代码再次压缩，不过需要配置服务器就没有采用了 1 2 3 4 5 6 7 8 9  const productionGzipExtensions = /\\.(js|css)$/i; new CompressionPlugin({ filename: \u0026#39;[path].gz[query]\u0026#39;, algorithm: \u0026#39;gzip\u0026#39;, test: productionGzipExtensions, threshold: 10240, minRatio: 0.8, deleteOriginalAssets: true }),   7 提高构建速度 HardSourceWebpackPlugin 为模块提供中间缓存，缓存默认的存放路径是: node_modules/.cache/hard-source。\n配置 hard-source-webpack-plugin，首次构建时间没有太大变化，但是第二次开始，构建时间大约可以节约 80%。\n1 2 3 4 5 6 7 8  //webpack.config.js var HardSourceWebpackPlugin = require(\u0026#39;hard-source-webpack-plugin\u0026#39;); module.exports = { //...  plugins: [ new HardSourceWebpackPlugin() ] }   使用后打包时间第一次30多秒，之后都差不多为8、9秒。\n","description":"","id":10,"section":"posts","tags":["前端","webpack"],"title":"webpack项目打包优化","uri":"https://blog.syzh.fun/posts/hxd/webpack-optimization/"},{"content":"本文对于webpack 编译出的内容做分析总结。\n普通文件引入的打包 1 2  // src/test.js module.exports = \u0026#39;test\u0026#39;   1 2 3  // src/index.js let test = require(\u0026#39;./test\u0026#39;); console.log(test)   打包后的main.js(摘取部分)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36  // 打包入口 ./src/index.js (function (modules) { var installedModules = {}; function __webpack_require__(moduleId) { // 缓存作用，如果已经引入过了，使用引入过的结果  if (installedModules[moduleId]) { return installedModules[moduleId].exports; } var module = installedModules[moduleId] = { i: moduleId, l: false, exports: {} }; modules[moduleId].call(module.exports, module, module.exports, __webpack_require__); module.l = true; return module.exports; } return __webpack_require__(__webpack_require__.s = \u0026#34;./src/index.js\u0026#34;); }) ({ // 包装成一个模块对象 绝对路径对应这个模块  \u0026#34;./src/index.js\u0026#34;: (function (module, exports, __webpack_require__) { // 将代码中的require -\u0026gt;__webpack_require__ t console.log(test) }), \u0026#34;./src/test.js\u0026#34;: (function (module, exports) { module.exports = \u0026#39;test\u0026#39; }) });   在我理解看来，在打包的过程中，每个模块被封装成了一个函数，此时模块代码并没有被执行，而是被放在了打包文件自执行函数的参数modules 中，从这个自执行函数的末尾\n1  return __webpack_require__(__webpack_require__.s = \u0026#34;./src/index.js\u0026#34;);   开始，根据入口文件引用的文件逐一运行，原文件中的require 被替代成__webpack_require__，也就是说，webpack打包的文件都没有使用node/es6的引用方法，而是自己实现的__webpack_require__方法。\n从__webpack_require__('./src/index.js')开始，拿到参数modules中被包装的index.js 的内容，遇到__webpack_require__('./src/test.js') 时，运行参数modules中./src/test.js 对应的封装方法，每运行完一个模块，就会为其生成一个module对象添加到installedModules，{ i: moduleId, l: false, exports:{}},保存其路径i，导出的内容exports，标记是否已经加载过l,installedModules 可以起到缓存的作用，如果已经加载过的模块可以直接从installedModules里拿到。\n不同引入方法的打包 众所周知，目前比较流行的模块加载方式是nodejs的module.exports/require 以及es6的 import/export,在webpack中这两种打包方式都支持，也就是上文中的__webpack_require__ 两种都支持，尝试通过es6 将上例中的test.js 修改成\n1 2  // src/test.js export const test = \u0026#39;test\u0026#39;   打包后的main.js(摘取部分)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61  (function(modules) { // webpackBootstrap  // The module cache  var installedModules = {}; // The require function  function __webpack_require__(moduleId) { if(installedModules[moduleId]) { return installedModules[moduleId].exports; } var module = installedModules[moduleId] = { i: moduleId, l: false, exports: {} }; modules[moduleId].call(module.exports, module, module.exports, __webpack_require__); module.l = true; return module.exports; } __webpack_require__.m = modules; __webpack_require__.c = installedModules; __webpack_require__.d = function(exports, name, getter) { if(!__webpack_require__.o(exports, name)) { Object.defineProperty(exports, name, { enumerable: true, get: getter }); } }; __webpack_require__.r = function(exports) { if(typeof Symbol !== \u0026#39;undefined\u0026#39; \u0026amp;\u0026amp; Symbol.toStringTag) { Object.defineProperty(exports, Symbol.toStringTag, { value: \u0026#39;Module\u0026#39; }); } Object.defineProperty(exports, \u0026#39;__esModule\u0026#39;, { value: true }); }; __webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); }; return __webpack_require__(__webpack_require__.s = \u0026#34;./src/index.js\u0026#34;); }) ({ \u0026#34;./src/index.js\u0026#34;: (function(module, exports, __webpack_require__) { let test = __webpack_require__(\u0026#34;./src/test.js\u0026#34;); console.log(test) }), \u0026#34;./src/test.js\u0026#34;: (function(module, __webpack_exports__, __webpack_require__) { __webpack_require__.r(__webpack_exports__); __webpack_require__.d(__webpack_exports__, \u0026#34;test\u0026#34;, function() { return test; }); const test = \u0026#39;test\u0026#39; }) });   可以看出，与上例中最大的区别是包装test.js 发生了变化，去除了export 关键字，并且添加了\n__webpack_require__.r(__webpack_exports__); __webpack_require__.d(__webpack_exports__, \u0026quot;test\u0026quot;, function() { return test; }); 查看__webpack_require__.r方法，发现是向模块运行结果exports中添加标记，标记当前模块__esModule 为true,如果是支持\nSymbol的浏览器，也添加一个Symbol值为Module，这种标记是为了后续有需要的地方可以识别此模块的导出方式，__webpack_require__.d 方法则是为当前导出的exports 对象上添加一个值为\u0026rsquo;test\u0026rsquo;的test 属性，如此一来，test.js 也有了module.exports = {test: \u0026lsquo;test\u0026rsquo;}的效果。\n同理，其他导出/导入组合，webpack 都会对包装函数做不同的处理，以便能统一达到效果。\n","description":"","id":11,"section":"posts","tags":["前端","webpack"],"title":"webpack 学习总结 三","uri":"https://blog.syzh.fun/posts/hxd/webpack-notes-3/"},{"content":"上一篇总结了webpack中使用的一些库，这一篇来总结下webpack整体流程,主要根据代码流程来总结。\n","description":"","id":12,"section":"posts","tags":["前端","webpack"],"title":"webpack 学习总结 二","uri":"https://blog.syzh.fun/posts/hxd/webpack-notes-2/"},{"content":"webpack 是当前前端项目打包当中非常流行的打包框架，结合丰富的流程钩子函数、插件系统以及nodejs部分功能 给开发者提供了方便配置，易于扩展的打包工具，在学习webpack源码流程(4.43.0)的这段时间收获很多，在此做一些总结。\n本文首先总结下，在webpack中用到的诸多工具项目，他们在实现整体流程中起到了很大的作用。\n一 Tapable Tapable是webpack流程的基础，整个编译过程，各个模块的方法调用都是基于Tapable的事件注册和触发。相对于nodejs 的EventEmitter，Tapable提供了事件触发的更多形式，同步触发，异步并行触发，异步串行触发等等，可以满足不同需求。\n在webapck中，最主要的Compiler和Compilation类都继承了\nTapable，从而可以生成自己的一系列钩子函数，这些钩子函数在流程控制中起到承上启下的作用，也为开发者自定义功能提供了灵活的接口。\n官网中的例子：\nconst { SyncHook, AsyncParallelHook, } = require(\u0026quot;tapable\u0026quot;); class Car { constructor() { this.hooks = { accelerate: new SyncHook([\u0026quot;newSpeed\u0026quot;]), brake: new SyncHook(), calculateRoutes: new AsyncParallelHook([\u0026quot;source\u0026quot;, \u0026quot;target\u0026quot;, \u0026quot;routesList\u0026quot;]) }; } /* ... */ } const myCar = new Car(); // 相当于给brake钩子添加一个事件（此时并不会执行，可以添加多个） myCar.hooks.brake.tap(\u0026quot;WarningLampPlugin\u0026quot;, () =\u0026gt; warningLamp.on()); // 触发钩子函数,可以在需要的时机来触发，webpack中正是利用这一点来统一给各流程添加逻辑 myCar.hooks.brake.call() 二 neo-async neo-async 其中的forEach 方法可以方便的进行异步循环，循环结束后执行回调,在webpack中处理模块依赖时需要用到该方法来确保在模块的所有依赖处理完成之后进行下一步。\n// array var order = []; var array = [1, 3, 2]; var iterator = function(num, done) { setTimeout(function() { order.push(num); done(); }, num * 10); }; async.each(array, iterator, function(err, res) { console.log(res); // undefined console.log(order); // [1, 2, 3] }); 三 Semaphore Semaphore\n是一个控制并发数量的工具，可以设置最大并发量，在任务结束时释放容量，每次take 一个任务时都会查看是否到达容量极限，如果到达会存储任务到队列中，等待容量被释放时再从队列中取出任务执行\n// 2 clients at a time var sem = require('semaphore')(2); var server = require('http').createServer(req, res) { res.write(\u0026quot;Then good day, madam!\u0026quot;); sem.take(function() { res.end(\u0026quot;We hope to see you soon for tea.\u0026quot;); sem.leave(); }); }); webpack中工厂函数生成多个模块 以及编译模块时都采用了\nSemaphore 来控制并发\n四 利用Object.defineProperty 重写get函数来添加一些内容获取的逻辑 let test = {arr: [1,2,2,3,4,5] } let res = {} Object.defineProperty(res, 'arr', { get() { // 这里可以自由添加自己需要的逻辑 return test.arr.filter(item=\u0026gt;item\u0026gt;1); } }); console.log(res.arr)// [2, 2, 3, 4, 5] webpack 中LoaderRunner.js 中就采用了这一技巧对loader进行信息采集\n","description":"","id":13,"section":"posts","tags":["前端","webpack"],"title":"webpack 学习总结 一","uri":"https://blog.syzh.fun/posts/hxd/webpack-notes-1/"},{"content":"  程序执行到defer语句的时候, 被defer的函数的实参会在此时被求值\n  1 2 3 4 5 6 7 8 9 10  func a() { i := 0 // 被defer的函数实参会在此时被求值, 这里为0  defer fmt.Println(i) // i自增, 但不会影响defer的函数  i++ return } //===========输出=========== 0       被defer的函数调用, 执行顺序是\u0026quot;后进先出\u0026quot;\n  defer的函数调用会被压入一个栈中。当外层函数返回时，被推迟的函数会按照后进先出的顺序调用。\n  如果函数的返回值是命名的, defer语句中的函数可以读取或修改该值\n  1 2 3 4 5 6 7 8 9  // 修改命名的返回值 func c() (i int) { // 在defer语句中自增  defer func() { i++ }() // 这里i被设为1  return 1 } //=============输出============ 2     1 2 3 4 5 6 7 8  // 返回值是匿名的, 无法被defer修改 func c() int { i := 1 defer func() { i++ }() return i } //=============输出============ 1       实参估值和修改返回变量的例子\n  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  func test() (x int) { // defer语句的实参会被立刻估值, 因此实参x==0  defer func(n int) { // 实参x估值为0, 因此形参n==0  fmt.Printf(\u0026#34;in defer x as parameter: x = %d\\n\u0026#34;, n) // 这里的x是外面的x, 因此为9  fmt.Printf(\u0026#34;in defer x after return: x = %d\\n\u0026#34;, x) }(x) x = 7 // x==9  return 9 } // =============执行结果============== in defer x as parameter: x = 0 in defer x after return: x = 9       最好在获取资源之后, 立刻调用defer\n  defer在其所在的函数的末尾执行, 因此在for循环中使用时要注意\n  1 2 3 4 5 6 7 8 9 10  // 有问题的写法 for _, filename := range filenames { f, err := os.Open(filename) if err != nil { return err } // 释放资源的操作直到所在函数末尾才执行, 如果文件很多, 可能导致文件描述符用尽  defer f.Close() // 处理文件 }     1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  // 改进写法 for _, filename := range filenames { if err := doFile(filename); err != nil { return err } } // 抽取处理单个文件的逻辑, 此函数返回时即可关闭文件 func doFile(filename string) error { f, err := os.Open(filename) if err != nil { return err } defer f.Close() // 处理文件 }       ","description":"","id":14,"section":"posts","tags":["后端","Golang"],"title":"Golang defer语句用法小结","uri":"https://blog.syzh.fun/posts/syzh/golang-defer/"},{"content":"  sync包提供传统的内存访问的同步机制\n  WaitGroup\n  等待若干goroutine执行完毕\n  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33  // 注意: 如果wg是在闭包环境中使用, 由于闭包中捕获的是变量本身, 因此直接使用wg变量即可. 但如果是下面代码这样, 作为函数的参数调用, 则需要传引用来保证使用的是同一个wg  // 传入公用的wg对象 hello := func(wg *sync.WaitGroup, id int) { // 执行完成后, 内部值-1  defer wg.Done() fmt.Printf(\u0026#34;Hello from %v!\\n\u0026#34;, id) } // 定义goroutine数量 const numGreeters = 5 // 初始化waitgroup var wg sync.WaitGroup // 一次性增加内部值, 也可以在for语句中逐个增加 wg.Add(numGreeters) for i := 0; i \u0026lt; numGreeters; i++ { // wg.Add(1) 如果使用逐个增加的方式  go hello(\u0026amp;wg, i+1) } // 阻塞, 直到内部值变为0 wg.Wait() //===========输出=============== // 顺序不确定 Hello from 1! Hello from 5! Hello from 2! Hello from 3! Hello from 4!       Mutex and RWMutex\n  保护关键区域(guard critical sections)\n  Mutex\n  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  var count int var lock sync.Mutex // 下面两个函数都是线程安全的 increment := func() { lock.Lock() // 使用defer, 确保锁被释放  defer lock.Unlock() count++ fmt.Printf(\u0026#34;Incrementing: %d\\n\u0026#34;, count) } decrement := func() { lock.Lock() defer lock.Unlock() count-- fmt.Printf(\u0026#34;Decrementing: %d\\n\u0026#34;, count) }       RWMutex\n  可以同时有任意多个读锁, 或一个写锁\n  读锁是共享的, 写锁是排他的\n  1 2 3 4 5 6 7 8 9 10 11 12 13 14  var mu sync.RWMutex var balance int func Balance() int { mu.RLock() // readers/shared lock  defer mu.RUnlock() return balance } func Deposit(amount int) { mu.Lock() // // writer/exclusive lock  defer mu.Unlock() balance += amount }         Cond\n  在某个点等待某事件(event)的发生, 在此之前保持阻塞/挂起状态, 使其他goroutine可以执行\n  用于notify的方法\n Signal: 通知等待最久的goroutine, 这个功能也可以用channel实现  runtime维护了一个FIFO保存等待通知的goroutine, 因此会通知等待最久的goroutine   Broadcast: 通知所有goroutine, 这个功能用channel不好实现    性能比使用channel实现好很多\n  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38  // 假设我们有一个固定len为2的queue, 我们想加入10个元素进去. 我们希望queue一有多余的空间, 就能通知我们, 让我们插入新的元素  // 创建一个cond, 需要传入一个sync.Locker来保护关键区域 c := sync.NewCond(\u0026amp;sync.Mutex{}) // 初始化queue queue := make([]interface{}, 0, 10) // dequeue函数 removeFromQueue := func(delay time.Duration) { // sleep delay的时间  time.Sleep(delay) // 使用lock保护关键区域  c.L.Lock() // dequeue  queue = queue[1:] fmt.Println(\u0026#34;Removed from queue\u0026#34;) // unlock, 离开关键区域  c.L.Unlock() // 通知等待最久的goroutine, 也可以用broadcast来通知所有  c.Signal() } for i := 0; i \u0026lt; 10; i++ { // 进入关键区域  c.L.Lock() // 需要使用for循环来检查条件. 因为接到通知并不一定意味着我们在等待的事情已经发生, 所以需要再次检查条件  for len(queue) == 2 { // 在内部会先调用unlock, 然后等待. 接到通知继续执行后, 会调用lock  c.Wait() } fmt.Println(\u0026#34;Adding to queue\u0026#34;) // enqueue  queue = append(queue, struct{}{}) // 启动goroutine, 1s后执行dequeue  go removeFromQueue(1 * time.Second) // 离开关键区域  c.L.Unlock() }       Once\n  每个sync.Once的对象, 只能调用1次Do方法, 之后的对Do的调用无效.\n  1 2 3 4 5 6 7 8 9 10 11 12  var count int increment := func() { count++ } decrement := func() { count-- } var once sync.Once // 第一次调用Do方法, 有效 once.Do(increment) // 此次调用Do方法无效 once.Do(decrement) fmt.Printf(\u0026#34;Count: %d\\n\u0026#34;, count) // count为1, once对象只能执行一次DO方法       Pool\n  创建一个对象池, 其中的对象可以复用(比如数据库连接), 且是线程安全的\n  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  myPool := \u0026amp;sync.Pool{ // 生成新对象  New: func() interface{} { fmt.Println(\u0026#34;Creating new instance.\u0026#34;) return struct{}{} }, } // pool是空的, 因此会创建新对象 myPool.Get() // 上面创建的对象没有被放回, 因此现在pool中还是空的 // 由于pool是空的, 因此会创建新对象 instance := myPool.Get() // 放回对象, 经常配合defer使用 myPool.Put(instance) // 由于pool中有对象, 因此不会创建新对象 myPool.Get() //============输出============ Creating new instance. Creating new instance.       ","description":"","id":15,"section":"posts","tags":["后端","Golang","GoSync"],"title":"Golang sync包用法小结","uri":"https://blog.syzh.fun/posts/syzh/golang-sync/"},{"content":"提供了Golang交替打印的几个思路: 使用Goroutine, sync包中的WaitGroup和Cond\n  使用unbuffered channel实现\n  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36  func PrintABUnbufferedChannel() { // 使用2个channel实现交替运行  c1 := make(chan struct{}) c2 := make(chan struct{}) // 打印aaa的函数, 对2个channel执行send操作  PrintA := func() { for { c1 \u0026lt;- struct{}{} fmt.Println(\u0026#34;aaa\u0026#34;) time.Sleep(1 * time.Second) c2 \u0026lt;- struct{}{} } } // 打印bbb的函数, 对2个channel执行receive操作  PrintB := func() { for { \u0026lt;-c2 fmt.Println(\u0026#34;bbb\u0026#34;) time.Sleep(1 * time.Second) \u0026lt;-c1 } } // 先打印aaa  go func() { \u0026lt;-c1 }() go PrintA() go PrintB() time.Sleep(1 * time.Hour) }       使用sync.Cond配合sync.WaitGroup实现\n  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54  func PrintABCond() { // 使用2个cond实现交替运行  c1 := sync.NewCond(\u0026amp;sync.Mutex{}) c2 := sync.NewCond(\u0026amp;sync.Mutex{}) // 使用waitgroup协调顺序, 确保printA, printB先启动, 再发送第一个signal  var wg sync.WaitGroup // 打印aaa的函数, 等待c1, 通知c2  printA := func() { // 确保printA启动早于第一个signal  wg.Done() for { c1.L.Lock() // 等待信号  c1.Wait() fmt.Println(\u0026#34;aaa\u0026#34;) time.Sleep(1 * time.Second) // 发送信号  c2.Signal() c1.L.Unlock() } } // 打印bbb的函数, 等待c2, 通知c1  printB := func() { // 确保printB启动早于第一个signal  wg.Done() for { c2.L.Lock() // 等待信号  c2.Wait() fmt.Println(\u0026#34;bbb\u0026#34;) time.Sleep(1 * time.Second) // 发送信号  c1.Signal() c2.L.Unlock() } } wg.Add(2) // 先打印aaa  go func() { // 等待printA, printB启动后, 再发送第一个signal  wg.Wait() c1.Signal() }() go printA() go printB() time.Sleep(1 * time.Hour) }       使用for-select语句实现, 与方法1类似\n  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  func PrintABForSelect() { c1 := make(chan struct{}) c2 := make(chan struct{}) printAB := func() { for { select { case \u0026lt;-c1: fmt.Println(\u0026#34;aaa\u0026#34;) time.Sleep(1 * time.Second) c2 \u0026lt;- struct{}{} case \u0026lt;-c2: fmt.Println(\u0026#34;bbb\u0026#34;) time.Sleep(1 * time.Second) c1 \u0026lt;- struct{}{} } } } go func() { c1 \u0026lt;- struct{}{} }() go printAB() go printAB() time.Sleep(1 * time.Hour) }       ","description":"","id":16,"section":"posts","tags":["后端","Golang","Goroutine","GoChannel","GoSync"],"title":"Golang交替打印的几种实现方式","uri":"https://blog.syzh.fun/posts/syzh/golang-goroutine-coordinate/"},{"content":"三色标记-清除算法(tricolor mark-and-sweep algorithm)\n 把heap中的对象, 用黑色, 灰色, 白色进行标记  黑色对象: 已经以其为root执行过可达性分析的对象 灰色对象: 需要但还未以其为root执行过可达性分析的对象 白色对象: 从gc root无法被触达的对象, 可能被垃圾回收   垃圾回收过程  垃圾回收开始时, 所有对象都是白色. 所有root对象被标记为灰色. root对象指程序可以直接访问的对象, 包含全局变量, 位于栈上的数据. 垃圾回收器选择一个灰色对象, 把它标记为黑色, 寻找其可以触达的白色对象, 并把它们标记为灰色. 直到把所有灰色对象都处理过一遍 此时的白色对象说明无法被触达, 因此可以被垃圾回收 如果在垃圾回收过程中, 某个灰色对象变得不可触达了, 则它会在下次垃圾回收时被清理   标记过程中, 执行中的应用程序被称为mutator, mutator有一个函数write barrier. 当heap中的某个对象被修改了, 说明该对象可被触达, 则write barrier会把此对象标记为灰色 当某channel无法被触达时, 即使其未被close, 也会被垃圾回收, 清理其占用的资源 手动触发GC: runtime.GC(), 此操作会阻塞调用者, 并可能阻塞整个程序 mark阶段, 标记对象; 没有灰色对象后, 开始sweep阶段 go的垃圾回收是与其他goroutine并发执行的  ","description":"","id":17,"section":"posts","tags":["后端","Golang","垃圾回收"],"title":"Golang垃圾回收-三色算法概览","uri":"https://blog.syzh.fun/posts/syzh/golang-garbage-collector-tricolor/"},{"content":"  问题表现\n  使用下标获取字符串的字符时, 可能得到奇怪的字符\n  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  func main() { s := \u0026#34;hello\u0026#34; fmt.Printf(\u0026#34;%c\\n\u0026#34;, s[1]) s = \u0026#34;你好\u0026#34; fmt.Printf(\u0026#34;%c\\n\u0026#34;, s[1]) } //============输出===========  e ½       问题原因\n golang是以utf8格式保存字符串的, 字符串的下标操作, 访问的是字节, 而不是字符. len函数输出的也是字节数, 如len(\u0026quot;hello\u0026quot;)==5, len(\u0026quot;你好\u0026quot;)==6    避免方式\n  把字符串转化为[]rune/[]int32, 或者使用range遍历\n  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  func main() { s := \u0026#34;你好\u0026#34; // 强转为[]rune  fmt.Printf(\u0026#34;%c\\n\u0026#34;, []rune(s)[1]) fmt.Println() // 使用range遍历  for _, c := range s { fmt.Printf(\u0026#34;%c\\n\u0026#34;, c) } } //===============输出=================  好 你 好       ","description":"","id":18,"section":"posts","tags":["后端","Golang","踩坑"],"title":"Golang踩坑总结-使用下标获取字符串的字符","uri":"https://blog.syzh.fun/posts/syzh/golang-pitfall-string-subscript/"},{"content":"  问题表现\n  goroutine中捕获的循环变量, 都为循环最后的值\n  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  func main() { for i, v := range []string{\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;, \u0026#34;d\u0026#34;, \u0026#34;e\u0026#34;} { // goroutine中捕获循环变量  go func() { fmt.Printf(\u0026#34;index: %v, value: %v\\n\u0026#34;, i, v) }() } // 此处应该使用waitgroup实现, 为了简单使用了sleep  time.Sleep(1 * time.Second) } //================输出==============  index: 4, value: e index: 4, value: e index: 4, value: e index: 4, value: e index: 4, value: e       问题原因\n goroutine中捕获的不是\u0026quot;值\u0026quot;, 而是\u0026quot;有地址的变量\u0026quot;. for循环可能会先结束, 之后各个goroutine才开始执行. 因此得到的是变量的最终值    避免方式\n  在goroutine启动的函数中, 把变量作为参数捕获\n  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  func main() { for i, v := range []string{\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;, \u0026#34;d\u0026#34;, \u0026#34;e\u0026#34;} { // 把循环变量作为参数传入  go func(i int, v string) { // i, v是函数内部的局部变量  fmt.Printf(\u0026#34;index: %v, value: %v\\n\u0026#34;, i, v) }(i, v) } time.Sleep(1 * time.Second) } //================输出==============  index: 0, value: a index: 1, value: b index: 4, value: e index: 3, value: d index: 2, value: c       ","description":"","id":19,"section":"posts","tags":["后端","Golang","踩坑","Goroutine"],"title":"Golang踩坑总结-循环中使用Goroutine中捕获参数","uri":"https://blog.syzh.fun/posts/syzh/golang-pitfall-for-goroutine/"},{"content":"  问题表现\n  闭包中捕获的循环变量, 都为循环最后的值\n  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  func main() { // 保存函数闭包  var s []func() for i, v := range []string{\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;, \u0026#34;d\u0026#34;, \u0026#34;e\u0026#34;} { s = append(s, func() { // 捕获i, v, 保存在闭包中  fmt.Printf(\u0026#34;index: %v, value: %v\\n\u0026#34;, i, v) }) } for _, f := range s { f() } } // ====================输出===========================  index: 4, value: e index: 4, value: e index: 4, value: e index: 4, value: e index: 4, value: e       问题原因\n 闭包中捕获的不是\u0026quot;值\u0026quot;, 而是\u0026quot;有地址的变量\u0026quot;. 最终执行时, 根据变量寻址, 得到的是变量最后的值    避免方式\n  在循环中, 重新声明要捕获的变量. 由于是单个循环的局部变量, 在其作用域结束前, 会进行evaluate\n  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  func main() { // 保存函数闭包  var s []func() for i, v := range []string{\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;, \u0026#34;d\u0026#34;, \u0026#34;e\u0026#34;} { // 重新声明要捕获的变量  i, v := i, v s = append(s, func() { // 捕获i, v, 保存在闭包中  fmt.Printf(\u0026#34;index: %v, value: %v\\n\u0026#34;, i, v) }) } for _, f := range s { f() } } // ====================输出===========================  index: 0, value: a index: 1, value: b index: 2, value: c index: 3, value: d index: 4, value: e       ","description":"","id":20,"section":"posts","tags":["后端","Golang","踩坑","闭包"],"title":"Golang踩坑总结-循环中使用闭包捕获参数","uri":"https://blog.syzh.fun/posts/syzh/golang-pitfall-for-closure/"},{"content":"  问题表现\n  具体类型的nil值, 赋值给接口值变量后, 被判定不为nil\n  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  func main() { // *bytes.Buffer, 零值为nil  var b *bytes.Buffer if b == nil { fmt.Println(\u0026#34;外面的b等于nil\u0026#34;) } else { fmt.Println(\u0026#34;外面的b不等于nil\u0026#34;) } f := func(b io.Writer) { if b == nil { fmt.Println(\u0026#34;里面的b等于nil\u0026#34;) } else { fmt.Println(\u0026#34;里面的b不等于nil\u0026#34;) } } // 把b传入函数  f(b) } //===========输出===============  外面的b等于nil 里面的b不等于nil       问题原因\n golang中的接口值, 除了有自己的类型type外, 还有动态类型(dynamic type)和动态值(dynamic value). 接口值如果要被判断为nil, 需要动态类型和动态值都为nil. 可以通过fmt的\u0026quot;%T\u0026quot;, \u0026ldquo;%v\u0026quot;观察动态类型和动态值    打印动态类型和动态值\n  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38  func main() { var b *bytes.Buffer fmt.Printf(\u0026#34;外面的b类型为%T\\n\u0026#34;, b) fmt.Printf(\u0026#34;外面的b值为%v\\n\u0026#34;, b) if b == nil { fmt.Println(\u0026#34;外面的b等于nil\u0026#34;) } else { fmt.Println(\u0026#34;外面的b不等于nil\u0026#34;) } fmt.Println(\u0026#34;\u0026#34;) f := func(b io.Writer) { fmt.Printf(\u0026#34;里面的b类型为%T\\n\u0026#34;, b) fmt.Printf(\u0026#34;里面的b值为%v\\n\u0026#34;, b) if b == nil { fmt.Println(\u0026#34;里面的b等于nil\u0026#34;) } else { fmt.Println(\u0026#34;里面的b不等于nil\u0026#34;) } } f(b) } //==============输出=================  外面的b类型为*bytes.Buffer 外面的b值为\u0026lt;nil\u0026gt; 外面的b等于nil 里面的b类型为*bytes.Buffer 里面的b值为\u0026lt;nil\u0026gt; 里面的b不等于nil       ","description":"","id":21,"section":"posts","tags":["后端","Golang","踩坑"],"title":"Golang踩坑总结-接口值是否等于nil","uri":"https://blog.syzh.fun/posts/syzh/golang-pitfall-interface-value-nil/"},{"content":"最近在用Golang搭建博客后端时, 遇到一个问题: 数据在从mysql到接口输出的json转化中, 需要做字段映射. 常规的方法是写db tag和json tag, 自动进行转换. 这种方式有点麻烦, 尤其struct和字段多起来的时候. 我的场景是mysql字段为snake_case, struct为CamelCase, json字段为snake_case, 就想着用代码来完成转换\n代码示例如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46  // 博客文章struct type Post struct { Content string Cover string CreatedAt time.Time FamilyID int ID int Slug string Status int Title string UpdatedAt time.Time } // struct和json互转 var keyMatchRegex = regexp.MustCompile(`\u0026#34;\\w+\u0026#34;:`) var wordBarrierRegex = regexp.MustCompile(`([a-z])([A-Z])`) // 重写Response类型的MarshalJSON方法 func (resp Response) MarshalJSON() ([]byte, error) { // 创建此类型, 防止递归  type Response_ Response marshalled, err := json.Marshal(Response_(resp)) // 正则替换  converted := keyMatchRegex.ReplaceAllFunc( marshalled, func(match []byte) []byte { return bytes.ToLower(wordBarrierRegex.ReplaceAll( match, []byte(`${1}_${2}`), )) }, ) return converted, err } // struct和db字段互转 var DB *sqlx.DB func init(){ // 使用sqlx包与数据库交互  DB = sqlx.MustConnect(\u0026#34;mysql\u0026#34;, \u0026#34;db connection\u0026#34;) // 支持自定义MapperFunc, 使用strcase包中的ToSnake  DB.MapperFunc(strcase.ToSnake) DB = DB.Unsafe() }   ","description":"","id":22,"section":"posts","tags":["后端","Golang"],"title":"Golang避免使用struct tag","uri":"https://blog.syzh.fun/posts/syzh/golang-reduce-json-db-tag/"},{"content":"js的继承总结 本质都是原型链，设置子类的prototype，应用的时候实例属性定义在实例上，通用方法定义在原型链上，达到较好的复用和扩展效果。 方法一 继承父类的实例 function Father() { this.property = true; // 实例属性 } Father.prototype.getFatherValue = function(){ return this.property; // 通用方法 } function Son(){ this.sonProperty = false; } Son.prototype = new Father();//继承 Son.prototype.getSonProperty = function(){ return this.sonProperty } var instance = new Son(); instance.getFatherValue() 方法二 object.create 此方法是《你不知道的js》所推荐的方法，已经被广泛使用，此方法可以避免 new Father() 有可能会带来的负面作用\nfunction Father() { this.property = true; // 实例属性 } Father.prototype.getFatherValue = function(){ console.log('father') return this.property; // 通用方法 } function Son(){ Father.apply(this,arguments) // 子类借用父类的构造方法 实现继承实例属性 } // 注意是 Father.prototype Son.prototype = Object.create(Father.prototype,{ constructor: { value: Father; // 弥补这种方法的不足 } }) // 或者添加一句 // Son.constructor = Father Son.prototype.getSonProperty = function(){ return this.sonProperty } var instance = new Son(); instance.getFatherValue() 方法三 es6 class 本质还是原型链的语法糖，但是对于面向对象开发友好\nclass Father { constructor(name) { this.name = name; // 增加到实例上 } // 这里声明的普通方法都添加到原型上 drink() { console.log('father drink') } } class Son extends Father { // 关键是extends constructor(name) { // 如果没有constructor 默认使用父类的 // 这里的super指向的是父类 默认里面的this就是子类 super(name); // Animal.call(this) } drink() { // super = Super.prototype 这个super不能单独打印 super.drink(); console.log('son drink') } } let son = new Son(); son.drink() // super 指向有两种可能 在constructor 和 static中指向的是父类 // 在子类的原型方法中指向的是父类原型 // 静态方法 就是通过类来调用的方法 方法四 Object.setPrototypeOf 原理 方法设置一个指定的对象的原型 ( 即, 内部[[Prototype]]属性），mdn 从性能考虑不建议 链接\n// 就是直接修改 __proto__ function Father() { this.property = true; // 实例属性 } Father.prototype.getFatherValue = function(){ console.log(123) return this.property; // 通用方法 } function Son(){ this.sonProperty = false; } Object.setPrototypeOf(Son.prototype,Father.prototype) Son.prototype.getSonProperty = function(){ return this.sonProperty } var instance = new Son(); instance.getFatherValue() ","description":"","id":23,"section":"posts","tags":["前端","JavaScript"],"title":"JavaScript的继承总结","uri":"https://blog.syzh.fun/posts/hxd/js-inheritance/"},{"content":"虽然博客不多, 写博客以来的时间不长, 但是折腾并不少\u0026hellip;记录一下这个博客的折腾历程 Golang时期 最初是想写个博客, 巩固一下Golang知识的, 以及hxd同学刚刚学了react, 也可以练练手. 大部分准备工作也是这段时间做的\n购买域名 最初的域名是在google买的, 要20$一年, 后来偶然发现阿里云有在卖域名, 就是当前这个, 不到200块/10年, 觉得挺合适, 果断就买了\n购买服务器 趁着腾讯云搞活动, 88¥/年买的, 后来发现性能确实不行\u0026hellip;不过88一年也不能要求太高啦\n开发语言的选择 当时学了Golang和Rust, 想着区区一个博客, 用Rust岂不是杀鸡用牛刀了, 加上Golang在服务端开发上的优势, 于是选择了Golang来开发后端. 也为后来用Rust重写买下了伏笔\u0026hellip;\nWeb框架的选择 其实Golang做服务端开发已经够方便了, 也有很多人推荐不使用框架. 基于在reddit里的探索, 选择了一个简单的router: go-chi\nORM的选择 没有选择GORM, XORM等, 感觉有点重量级了. 多方探索, 选择了sqlx\nhttps证书 使用了acme.sh, 免费, 且支持自动更新\nRust时期 大概2019年12月的时候, Rust支持了async/await语法, 于是想动手试一试, 拿博客开刀了\nWeb框架的选择 Rust作为性能著称的语言, 很多框架也都同时支持异步. 比如actix-web, warp, tower-web, tide. 最终选择了相对简单的tide框架(与tide对应, 还有一个异步http client: surf. 二者都是http-rs的作品, 寓意surf the tide)\nMysql Client Rust社区当时现有的Mysql Client, 大多数不支持异步, 支持异步的里面, 又大多数不支持Mysql\u0026hellip;最终选择了sqlx, 支持编译时检查sql语句\n与Golang博客的性能对比 写完后, 用wrk工具对比了下二者的性能, Rust版本的还是比较快. 当然Golang版本使用的是同步的逻辑, 如果使用Goroutine请求数据库, 可能也会很快.\nGohugo时期 服务器还有几个月就要到期了, 一想到又要配置Mysql, Redis, 以及未完成的elasticsearch搜索, 评论功能等, 就有点头大. 虽说用docker可以解决, 但是还有什么比静态网站更省心呢\u0026hellip;\n静态网站生成器的选择 这个没做太多比较, 了解到有Hexo, Gohugo, Rust Zola等等. Gohugo各方面都满足我需求, 就选了这个\nHugo theme的选择 静态网站的话, theme应该是最重要的选择了. 列举了一下自己需要的功能:\n 首页列表简洁 支持明暗配色 支持分类/标签 文章支持显示目录 列表中的文章, 支持配图 最好支持搜索 最好支持手机浏览   比较了一些, 把范围缩小在zzo, even, jane, 最终选择了zzo(zzo还支持相册, 演示, 陈列柜, 出版物等功能, 有兴趣的同学可以研究下)\n评论系统的选择 本着纯静态的思想, 选择了utterances, 基于GitHub issues. 缺点是需要登录GitHub授权, 以及可能需要科学上网\n持续折腾中\u0026hellip; 最后, 希望自己和hxd同学能坚持写这个博客, 积少成多, 加油💪\n","description":"","id":24,"section":"posts","tags":["博客"],"title":"博客折腾记(持续更新)","uri":"https://blog.syzh.fun/posts/syzh/blog-system-change-updating/"},{"content":"随着公司的发展和项目的迭代，很多团队都维护者一个越来越庞大的前端项目群，其中可能有jquery项目，vue项目，react项目，如何更好的分割和整合项目，成为很多工程师的需求。参考后端微服务的概念，前端提出了微前端的方案。\nsingle-spa是其中比较有人气的，本文也是在基于学习这里的内容给出的总结。同时也研究了\n这里 的代码\n微前端的优势：\n 在同一页面上使用多个前端框架 而不用刷新页面 (React, AngularJS, Angular, Ember, 你正在使用的框架) 独立部署每一个单页面应用 新功能使用新框架，旧的单页应用不用重写可以共存 改善初始加载时间，延迟加载代码  在我理解来看，微前端主要满足用一个更好的调度框架，来调度各个不同项目在页面的展示的需求。\n例如 /#reactApp 就加载react项目，\n/#vueApp 就加载vue项目，路由切换可以卸载当前项目，切换新项目。说到底每个项目就是一个通过打包之后的bundle.js,也就是说路由切换可以加载不同的js进来，每个js都维护一个单页应用。\n在single-spa 中，每一个项目都是一个application,以下简称app,为了single-spa可以很好的调度各项目的加载，卸载流程，首先每个项目需要包装统一接口，\n1 2 3 4 5  const app1 = { bootstrap: () =\u0026gt; Promise.resolve(), //bootstrap function  mount: () =\u0026gt; Promise.resolve(), //mount function  unmount: () =\u0026gt; Promise.resolve(), //unmount function }   每个项目都有 bootstrap，mount,unmout 回调，其中回调返回promise,也可以包含一个数组，其中每一项都是返回promise的函数。promise 支持后面强大的链式调用，可以让single-spa将app 像管道一样筛选，加载，卸载。app回调函数会在single-spa合适的调度时机被调用。\n其中例如mount 回调中，不同的app可以分别执行自己的渲染,single-spa会传入参数，也就是说不同的app都需要调整自己的入口文件，满足app的回调才能嵌入这个更加灵活的整体\n1 2 3 4 5 6 7 8 9 10  export function mount(props) { return Promise .resolve() .then(() =\u0026gt; { // Do framework UI rendering here  // 这里可以分别调用react/vue 的渲染  console.log(\u0026#39;mounted!\u0026#39;) }); }   为了更加方便得控制app,分类app,手写微前端框架 提出了app的11个状态，每个状态对应一个app 在加载/启动/挂载/卸载 过程中的某个阶段，任何一个阶段出错了，状态都成为出错状态，不可逆。\n为了确保single-spa 处理路由在任何app之前，采用拦截window.addEventlistener 的方法，在拦截的方法里将hashchange|popstate 这连个事件存储起来，先不执行，默认只执行single-spa添加的hashchange|popstate，等到single-spa 控制流程结束，再依次触发（此时就是react-router、vue-router等绑定的事件）\n整个流程的核心在于single-spa 的核心流程，默认首先加载被注册的app，然后判断是否需要挂载/卸载app,如果浏览器或者手动触发了需要更改app,再依次执行卸载不需要的，挂载需要的app流程。此流程核心代码位于/my-single-spa/src/navigation/invoke.js\n","description":"","id":25,"section":"posts","tags":["前端"],"title":"微前端学习总结","uri":"https://blog.syzh.fun/posts/hxd/micro-front-end/"},{"content":"mac app   快捷启动: alfred\n alfred基本算是mac必备app了, 主要用到的功能如下  快捷启动 文件搜索 snippets短语扩展 计算器 字典 密码管理1password   workflows  颜色色值相关转换: Colors v2.0.2 时间格式相关转换: Datetime Format Converter 编解码: Encode / Decode v1.8.0 快捷打开项目: JetBrains - Open project 命令用法速查: tldr uuid生成器: uuid generator      数据库连接: sequel pro\n 虽然已经基本停止开发了, 也尝试过其他诸如datagrip, 不过不习惯, 又换回来了    备份: mac自带的time machine\n  gif录屏: licecap\n  pdf阅读器: skim/pdfelement, 后者备用\n  任务管理: omniFocus\n  视频播放器: iina\n  键盘自定义映射: karabiner\n 把长按enter映射为ctrl, 点击capslock映射为esc, 长按capslock映射为ctrl等等 更多复杂映射, 比如emacs专用映射等等, 可以在这里找到    系统指标监视器: istat menus\n 在菜单栏显示上下行流量, cpu温度, cpu使用率等等    终端: iterm\n  密码管理: 1password\n  清理键盘辅助工具: KeyboardCleanTool\n  文本编辑器: sublime/vscode\n  工作休息提醒: stretchly\n  浏览图片: xnviewMP\n  文件同步: dropbox\n  抓包: charles\n  菜单栏图标管理: bartender\n  自动切换壁纸: irvue\n  思维导图: scapple\n  听歌: spotify + telegram\n telegram的vk music bot机器人可以搜索并下载各种歌曲, 而且自带的音乐播放功能还不错\u0026hellip;    markdown编辑器: typora + ipic\n typora可以支持很多$\\LaTeX$公式符号等等 ipic可以帮助typora自动上传图片    命令行工具  包管理器: homebrew http客户端: httpie git diff增强: diff-so-fancy 文件查找(替代find): fd shell: fish 命令历史查找: fzf 文件内容搜索(替代grep): ripgrep  各种ide/编辑器配色方案: dracula 在线latex编辑器: overleaf ","description":"","id":26,"section":"posts","tags":["MacOS"],"title":"记录一下mac里装的应用","uri":"https://blog.syzh.fun/posts/syzh/my-mac-app/"},{"content":"小站的评论系统使用了utterances, 基于GitHub issues, 因此可能需要科学上网支持\n不方便的同学, 欢迎通过每篇博文底部的作者邮箱或Github账号与我们联系\n","description":"Hugo, the world’s fastest framework for building websites","id":31,"section":"","tags":null,"title":"About","uri":"https://blog.syzh.fun/about/"}]