[{"content":"vue3.0已经正式发布了，作为曾经vue2.0的用户当然迫不及待要来认识一下，趁假期有时间赶紧来小试牛刀～\n在查看文档和一些demo的过程中发现一下午想掌握所有新货有点好高骛远了，那么就从3.0中备受瞩目也是最常会用到的composition-api 来开始吧。\ncomposition-api 提出的原因是，在vue组件的逻辑中，我们原来的options api 是主张在组件内，根据逻辑来将代码写到对应的位置的，就是如下的结构\n1 2 3 4 5 6 7 8 9 10 11  export default { data () { return {} }, methods: {}, computed: {}, watch: {} }   在这种结构中，随着组件逻辑更加复杂，零落在各个参数中的函数/逻辑 复用困难，且无法和组件的生命周期结合，于是vue3.0 提出了composition-api，可以提取代码逻辑到一个单独的、可以利用生命周期函数的函数中来达到充分的逻辑复用，使我们的代码可以更加灵活的组合。\n首先根据官网的安装指导来安装最新版本的vue，然后尝试做一个简易的todo list，要使用composition-api ，意味着我们的组件中不再有data,methods等2.0中的结构，setup函数是composition-api 的入口点，在组件初始化props 和beforeCreate 之间执行一次，setup返回的内容可以直接在组件中使用，那么如何达到数据变化页面更新的效果呢？答案就是在setup中使用vue 提供的各种composition-api 来达到这种目的。\n我想实现可以添加待做事项，以及勾选事项代表该项已经做完，并且分别展示待做和已做列表，代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63  \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;div\u0026gt; \u0026lt;input placeholder=\u0026#34;输入待办\u0026#34; type=\u0026#34;text\u0026#34; :value=\u0026#34;todoText\u0026#34; @input=\u0026#34;($event)=\u0026gt;{todoText = $event.target.value}\u0026#34;\u0026gt; \u0026lt;button @click=\u0026#34;addItem\u0026#34;\u0026gt;添加\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;p\u0026gt;待办事项：\u0026lt;/p \u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li v-for=\u0026#34;(item,i) in tobeDone\u0026#34; :key=\u0026#34;item.text\u0026#34; @click=\u0026#34;checkItem(item,i)\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;checkbox\u0026#34; name=\u0026#34;item.text\u0026#34; value=\u0026#34;item.text\u0026#34;\u0026gt;{{item.text}}\u0026lt;br\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;p\u0026gt;已办完：\u0026lt;/p \u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li v-for=\u0026#34;(item) in haveDone\u0026#34; :key=\u0026#34;item.text\u0026#34; \u0026gt; \u0026lt;span\u0026gt;{{item.text}}\u0026lt;/span\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import { ref, reactive, computed } from \u0026#39;vue\u0026#39; export default { name: \u0026#39;App\u0026#39;, setup() { let todoText = ref(\u0026#39;\u0026#39;); // 返回 {value:\u0026#39;\u0026#39;} 适用于简单双向绑定数据 defineproperty 实现  let todoItems = reactive({list:[]}); // 适用于复杂引用类型双向绑定数据 proxy代理实现  function addItem() { // state 0 未做 1 已做  todoItems.list.push({text:todoText.value,state:0}); todoText.value = \u0026#39;\u0026#39;; } function checkItem(item) { item.state = item.state=== 0? 1 : 0; } // composition api 中的computed  // 筛选已做好的  let haveDone = computed(()=\u0026gt;{ return todoItems.list.filter(item =\u0026gt; item.state === 1); }) // 筛选未做好的  let tobeDone = computed(()=\u0026gt;{ return todoItems.list.filter(item =\u0026gt; item.state === 0); }) return { // 返回的内容在组件中都可以直接拿到,不反回会在template中引用时候报错  todoItems, addItem, todoText, checkItem, haveDone, tobeDone } } } \u0026lt;/script\u0026gt;   完成效果如下：\n从以上代码中可以看出，在vue3.0 中的组件中，使用composition-api 后逻辑主要集中在setup 中，这不禁让人觉得setup 中的代码不会过于臃肿和复杂吗？当然不会，在实际应用场景中，我们有很多拉取接口数据和在生命周期中某个阶段需要有一些动作的场景，这些都可以从setup 函数中抽离出来形成一个独立的js 模块提供封装好的某一部分逻辑，这些在官方指导中都有更多的示例和说明。\n总体来说，在做这个demo的过程中，感觉到在应用到vue3.0的时候需要对每一个点去新文档中确认是否有变化，比如这里的v-model 就跟原来的用法有变化，直接用2.0还是无法与composition api 相适应的。另外，整体看来似乎跟react中的函数式组件+钩子函数有一些相似的用法，在编写组件的过程更多的是考虑数据的变化，生命周期函数只是完成功能的一个辅助力量，不像之前在编写组件的过程主线是vue实例的生命周期过程，另外，vue3.0 也提供了更多针对数据的api,例如isRef,isReadonly,isProxy 等等，对不同的场景使用不同的数据处理方式可以得到更好的组件性能。\n参考：\nhttps://vue3js.cn/docs/zh/guide/installation.html\nhttps://vue3js.cn/docs/zh/guide/composition-api-introduction.html#%E4%BB%80%E4%B9%88%E6%98%AF-composition-api\n","description":"","id":2,"section":"posts","tags":["前端","vue-3.0"],"title":"vue3.0的Composition-API","uri":"https://blog.syzh.fun/posts/hxd/vue-3.0-composition-api/"},{"content":"前言 ​ 我们都知道，在用react开发前端应用时，有类组件和函数组件两种形式来编写组件，其中函数组件有自己的状态state，每次调用setState 都会有一个更新组件需求添加到队列中，从而实现页面跟随数据变化而更新。随着前端生态的发展，React 16.8 引入hook 的概念，可以让我们在编写相对于类组件更加轻便灵活的函数式组件的同时，也能拥有组件内部的状态（useState）、生命周期函数（useEffect）等类组件的特性。本文就部分钩子的作用和实现做一些总结和探讨。\n一 最常使用的useState 首先将官网的demo拿过来：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  import React, { useState } from \u0026#39;react\u0026#39;; function Example() { // 声明一个叫 \u0026#34;count\u0026#34; 的 state 变量  const [count, setCount] = useState(0); return ( \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;You clicked {count} times\u0026lt;/p \u0026gt; \u0026lt;button onClick={() =\u0026gt; setCount(count + 1)}\u0026gt; Click me \u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); }   useState 实现了：\n 传入一个state 初始变量 返回state引用和改变state的回调 如果state改变 更新组件  在我们理解函数组件的时候，本质上它是一个函数，每当组件更新，就会重新执行一遍函数，如果函数内正常声明的变量，都是会重新声明一遍，跟上一次函数的执行时声明的变量毫无关系，那么如果我们想要每次执行函数时能有一个变量始终基于上一次函数执行后的结果上再更改，就只有一个办法： 在函数外声明一个变量，又因为我们需要监听状态变化来重新渲染，所以需要将更改状态的操作抽离到一个函数中，由此可以在更改状态后添加更新一以及其他一些逻辑，实现一个自己的setState:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43  import React from \u0026#39;react\u0026#39;; import ReactDOM from \u0026#39;react-dom\u0026#39;; // hook 相关的变量存储 let hook = { memoizedState: null, } function useState(initialState) { // 这里也可以添加对initialState 是否是函数的判断来支持 react惰性初始 state  // 也就是initialState 如果是函数，执行函数返回结果作为initialState  hook.memoizedState = hook.memoizedState || initialState; function setState(state) { hook.memoizedState = state; // 由于源码中这里关联fiber，简化它门的dispatch重新渲染的逻辑  render(); // state 变化重新渲染  } return [hook.memoizedState, setState]; // 返回数组便于用户解构和重命名 } function Example() { // 声明一个叫 \u0026#34;count\u0026#34; 的 state 变量  const [count, setCount] = useState(0); return ( \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;You clicked {count} times\u0026lt;/p \u0026gt; \u0026lt;button onClick={() =\u0026gt; setCount(count + 1)}\u0026gt; Click me \u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } function render(){ ReactDOM.render( \u0026lt;Example/\u0026gt;, document.getElementById(\u0026#39;root\u0026#39;) ); } render();   二 第二常用的useEffect useEffect 实现了：\n 默认情况下，effect 将在每轮渲染结束后执行（没有依赖） 组件更新后如果依赖的变量数组有变化，执行回调 （有依赖项）  同理，要想比较两次函数中声明的变量是否相同，需要在函数外声明缓存变量来比较，由于是依赖数组，需要有一个循环依次比较数组的每一项：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62  import React, { useState } from \u0026#39;react\u0026#39;; import ReactDOM from \u0026#39;react-dom\u0026#39;; // hook 相关的变量存储 // 这里为方便演示，只有一个lastDeps，真实场景中应该为每一次useEffect 分配一个lastDeps/destroy let hook = { lastDeps: null, destroy: null // useEffect 返回的销毁函数 } function useEffect(create,deps) { if (!hook.lastDeps) { // 第一次渲染  hook.destroy = create(); // 缓存useEffect的清除函数  hook.lastDeps = deps; } else { let isSame = hook.lastDeps.every((item,index) =\u0026gt; { return item === deps[index]; }); if (!isSame) { hook.destroy(); // 在执行新的回调前先执行清除函数  hook.destroy = create(); hook.lastDeps = deps; } } } function Example() { // 声明一个叫 \u0026#34;count\u0026#34; 的 state 变量  const [count, setCount] = useState(0); const [stable, setStable] = useState(2); // 依赖count 或者不添加依赖数组会导致每次组件更新都执行  useEffect(() =\u0026gt; { document.title = count; return ()=\u0026gt;{ console.log(\u0026#39;clear\u0026#39;); } },[count]) // 依赖一个不变化的变量只执行一次回调  // useEffect(() =\u0026gt; {  // console.log(\u0026#39;test\u0026#39;);  // },[stable])  return ( \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;You clicked {count} times\u0026lt;/p \u0026gt; \u0026lt;button onClick={() =\u0026gt; setCount(count + 1)}\u0026gt; Click me \u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } function render(){ ReactDOM.render( \u0026lt;Example/\u0026gt;, document.getElementById(\u0026#39;root\u0026#39;) ); } render();   以上的例子只是为了理解useEffect 原理而写的例子，在真实场景中，官网中指出：与 componentDidMount、componentDidUpdate 不同的是，在浏览器完成布局与绘制之后，传给 useEffect 的函数会延迟调用，官网还指出： 为防止内存泄漏，清除函数会在组件卸载前执行，所以在上面的例子中，create和destroy 函数的执行时机是不准确的，在react机制中应该是有更加复杂的调度。\n三 通常常用的useCallback 官网中的解释是把内联回调函数及依赖项数组作为参数传入 useCallback，它将返回该回调函数的 memoized 版本，该回调函数仅在某个依赖项改变时才会更新,当你把回调函数传递给经过优化的并使用引用相等性去避免非必要渲染（例如 shouldComponentUpdate）的子组件时,它将非常有用，当我们在函数组件中声明一个函数，那么每次执行渲染都会声明这个新的函数，如果此函数是传递给子组件的一个属性，那么每次函数更新都会传递给子组件全新的函数，在使用memo包装子组件的时候结合useCallback 可以有效减少子组件不必要的重新渲染：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79  import React, { useState ,memo} from \u0026#39;react\u0026#39;; import ReactDOM from \u0026#39;react-dom\u0026#39;; let hook = { lastCallback: null, lastDeps: null, } function useCallback(cb,deps) { if (!hook.lastCallback) { // 第一次渲染  hook.lastCallback = cb; hook.lastDeps = deps; return cb; } else { let isSame = hook.lastDeps.every((item,index) =\u0026gt; { return item === deps[index]; }) if (!isSame) { hook.lastCallback = cb; hook.lastDeps = deps; return cb; } else { return hook.lastCallback; } } } function Child(props) { console.log(\u0026#39;child render\u0026#39;); return ( \u0026lt;div\u0026gt; \u0026lt;br /\u0026gt; \u0026lt;span onClick={props.handleClick}\u0026gt; I am child\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; ) } Child=memo(Child); // memo 包装的组件在属性不变时不再重新渲染  function Example() { // 声明一个叫 \u0026#34;count\u0026#34; 的 state 变量  const [count, setCount] = useState(0); const [count2, setCount2] = useState(0); // 这样写每次传递给Child 组件的handleClick 都是全新的函数  // 点击add count2 -\u0026gt; 组件刷新 -\u0026gt;handleClick是新的函数 -\u0026gt;Child 组件props变化重新渲染  // let handleClick = () =\u0026gt; {  // setCount(count + 1);  // }  // 点击add count2 -\u0026gt; 组件刷新 -\u0026gt;handleClick是旧的函数 -\u0026gt;Child 组件不会重新渲染  let handleClick = useCallback(() =\u0026gt; { setCount(count + 1); },[count]) return ( \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;count {count}\u0026lt;/p \u0026gt; \u0026lt;button onClick={() =\u0026gt; setCount(count + 1)}\u0026gt; add count \u0026lt;/button\u0026gt; \u0026lt;br /\u0026gt; \u0026lt;p\u0026gt;count2 {count2}\u0026lt;/p \u0026gt; \u0026lt;button onClick={() =\u0026gt; setCount2(count2 + 1)}\u0026gt; add count2 \u0026lt;/button\u0026gt; \u0026lt;Child handleClick={handleClick}/\u0026gt; \u0026lt;/div\u0026gt; ); } function render(){ ReactDOM.render( \u0026lt;Example/\u0026gt;, document.getElementById(\u0026#39;root\u0026#39;) ); } render();   总结来说，优化都是靠函数外声明的变量来缓存值，并且在每次调用函数时做优化判断，在应用钩子函数的时候，要想达到理想的效果，需要尽可能理清在渲染过程的这些动作，避免引起更多bug 的情况。\n参考 https://zh-hans.reactjs.org/docs/hooks-state.html\n​ https://www.jianshu.com/p/61d6193e04da\n​ https://www.lagou.com/lgeduarticle/103675.html\n","description":"","id":3,"section":"posts","tags":["前端"],"title":"react-hooks 初探","uri":"https://blog.syzh.fun/posts/hxd/react-hooks-study/"},{"content":"一 问题背景 最近在使用G6 展示树状图的时候需要有导出图片的需求，于是使用graph.downloadFullImage 方法来导出canvas 内容到一个图片，在导出的过程中发现，如果树的内容量庞大，会出现导出的图片是0kb 的情况，本文就是对此问题的一个记录。\n二 尝试解决过程 首先找到了源码中graph.downloadFullImage 的位置，/node_modules/_@antv_g6@3.6.1@@antv/g6/es/graph/graph.js，在调用\ngraph.downloadFullImage 方法前设置断点，发现进入的是压缩后文件，原来package.json 中默认入口设置的是 \u0026ldquo;main\u0026rdquo;: \u0026ldquo;lib/index.js\u0026rdquo;,，为了可以进入源码调试，将引入G6 处修改：\n1 2  // import G6ES from \u0026#39;@antv/g6\u0026#39;; import G6ES from \u0026#39;@antv/g6/es/index\u0026#39;; // 调试源码走这里   再次调试可以进入未压缩的源码中。\n在调试过程中，发现不同的数据，在调用canvas.toDataURL 方法返回的内容不同，由此发现了出现问题的位置,下图分别展示了数量小和数据量大的时候调试到此处的情形,都是在node_modules/_@antv_g6@3.6.1@@antv/g6/es/graph/graph.js的downloadFullImage方法内\n发现了这个问题后，决定在本地代码中验证是否是这个原因，于是在方法中自己调用canvas.toDataURL 查看：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  // 省略部分react 组件代码 let [imgSrc,setImgSrc] = useState(\u0026#39;\u0026#39;); const handleMyExport = () =\u0026gt; { const canvas = document.getElementsByTagName(\u0026#39;canvas\u0026#39;)[0]; var dataURL = canvas.toDataURL(); console.log(dataURL); setImgSrc(dataURL); } return ( \u0026lt;div className=\u0026#34;App\u0026#34; \u0026gt; \u0026lt;button style={{position:\u0026#34;absolute\u0026#34;,top: 0,left: \u0026#39;110px\u0026#39;,zIndex: 999}} onClick={handleMyExport}\u0026gt;我的导出\u0026lt;/button\u0026gt; \u0026lt;div ref={ref}\u0026gt;\u0026lt;/div\u0026gt; \u0026lt; img src={imgSrc} alt=\u0026#39;\u0026#39; style={{position:\u0026#39;absolute\u0026#39;, top: \u0026#34;820px\u0026#34;}}/\u0026gt; \u0026lt;/div\u0026gt; );   在调试过程发现使用大量数据的时候，这里的canvas.toDataURL() 可以生成图片base64 编码，在img 标签中是可以展示图片内容的，这是什么原因？对比发现，这里的图片只展示的canvas 画布中的内容，远小于真正cavans 中大数据量需要展示的数据，downloadFullImage导出的图片是包括canvas 中不可见部分的内容的，由此可见是导出全图的大数量数据导致的0kb 问题。\n继续查看downloadFullImage 方法，发现他在导出全图的过程是通过生成一个新canvas 标签（new GCanvas(canvasOptions); 宽高是canvas 全部内容的宽高），不是在当前graph 所拥有的canvas 标签上导出的，以下摘出downloadFullImage 方法并添加部分注释\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71  /** * 导出包含全图的图片 * @param {String} name 图片的名称 * @param {String} type 图片类型，可选值：\u0026#34;image/png\u0026#34; | \u0026#34;image/jpeg\u0026#34; | \u0026#34;image/webp\u0026#34; | \u0026#34;image/bmp\u0026#34; * @param {Object} imageConfig 图片配置项，包括背景色和上下左右的 padding */ Graph.prototype.downloadFullImage = function (name, type, imageConfig) { var _this = this; var bbox = this.get(\u0026#39;group\u0026#39;).getCanvasBBox(); // 获取画布的包围盒 包括不可见部分内容  var height = bbox.height; var width = bbox.width; var renderer = this.get(\u0026#39;renderer\u0026#39;); // canvas  var vContainerDOM = createDom(\u0026#39;\u0026lt;id=\u0026#34;virtual-image\u0026#34;\u0026gt;\u0026lt;/div\u0026gt;\u0026#39;); var backgroundColor = imageConfig ? imageConfig.backgroundColor : undefined; var padding = imageConfig ? imageConfig.padding : undefined; if (!padding) padding = [0, 0, 0, 0];else if (isNumber(padding)) padding = [padding, padding, padding, padding]; var vHeight = height + padding[0] + padding[2]; // 将要生成的canvas 高度  var vWidth = width + padding[1] + padding[3]; // 将要生成的canvas宽度  var canvasOptions = { container: vContainerDOM, height: vHeight, width: vWidth }; var vCanvas = renderer === \u0026#39;svg\u0026#39; ? new GSVGCanvas(canvasOptions) : new GCanvas(canvasOptions); var group = this.get(\u0026#39;group\u0026#39;); var vGroup = group.clone(); var matrix = clone(vGroup.getMatrix()); if (!matrix) matrix = [1, 0, 0, 0, 1, 0, 0, 0, 1]; var centerX = (bbox.maxX + bbox.minX) / 2; var centerY = (bbox.maxY + bbox.minY) / 2; mat3.translate(matrix, matrix, [-centerX, -centerY]); mat3.translate(matrix, matrix, [width / 2 + padding[3], height / 2 + padding[0]]); vGroup.resetMatrix(); vGroup.setMatrix(matrix); vCanvas.add(vGroup); var vCanvasEl = vCanvas.get(\u0026#39;el\u0026#39;); // 将要生成图片的canvas  if (!type) type = \u0026#39;image/png\u0026#39;; setTimeout(function () { var dataURL = \u0026#39;\u0026#39;; if (renderer === \u0026#39;svg\u0026#39;) { ... } else { var imageData = void 0; var context = vCanvasEl.getContext(\u0026#39;2d\u0026#39;); var compositeOperation = void 0; if (backgroundColor) { var pixelRatio = window.devicePixelRatio; imageData = context.getImageData(0, 0, vWidth * pixelRatio, vHeight * pixelRatio); compositeOperation = context.globalCompositeOperation; context.globalCompositeOperation = \u0026#34;destination-over\u0026#34;; context.fillStyle = backgroundColor; context.fillRect(0, 0, vWidth, vHeight); } dataURL = vCanvasEl.toDataURL(type); // 生成图片base64 编码  } // 生成a链接完成下载效果  var link = document.createElement(\u0026#39;a\u0026#39;); var fileName = (name || \u0026#39;graph\u0026#39;) + (renderer === \u0026#39;svg\u0026#39; ? \u0026#39;.svg\u0026#39; : \u0026#34;.\u0026#34; + type.split(\u0026#39;/\u0026#39;)[1]); _this.dataURLToImage(dataURL, renderer, link, fileName); var e = document.createEvent(\u0026#39;MouseEvents\u0026#39;); e.initEvent(\u0026#39;click\u0026#39;, false, false); link.dispatchEvent(e); }, 16); };   查看canvas 的 toDataURL 方法，发现指出\u0026rsquo;如果画布的高度或宽度是0，那么会返回字符串“data:,”。',再次调试，发现vCanvasEl 的宽度和高度都不为0:\n经查canvas 元素大小在各浏览器中都有限制，\n那么针对这个限制如何应用于我们的导出需求呢？以下是我的几种方案：\n1、 针对导出做限制，当大于我们的极限时，提醒用户当前图片太大，可以选择树结构的某一部分来导出。这个想法是基于我们导出图片的初衷的，初衷是为了让用户清晰的看出整个树结构，当我测试时导出的3.4M 的一张图已经大到每个节点都需要非常费力去放大才能看到，这与初衷相违背，不能为了导出而导出，产品需要考虑到这种情况通过交互去优化体验。\n2 、在一定范围内考虑通过scale 方法缩放后导出，在不影响导出图片的结构清晰的前提下。\n3 、还是非常想得到全图，就可以在downloadFullImage 方法的基础上，添加对图片宽高的判断和计算，比如将图片切割为上下左右4个部分，得到每个部分的canvas限制内的图片base64,上传到后端，由后端小伙伴拼接成一张图返回，此方法基于用canvas 实现截图功能，麻烦的是要根据当前canvas 的宽高来决定如何分割，总体上是可以实现的。\n以上，这个问题暂时告一段落。\n参考：\n  https://g6.antv.vision/zh/docs/api/Graph\n  https://stackoverflow.com/questions/43860035/canvas-todataurl-returns-data-when-canvas-width-height-is-too-large\n  https://blog.csdn.net/HuangsTing/article/details/106141263\n  ","description":"","id":4,"section":"posts","tags":["前端"],"title":"antv.G6 导出全图得到0 bytes 的问题","uri":"https://blog.syzh.fun/posts/hxd/antv-g6-export-pic-zero-bytes/"},{"content":"在最近一段时间的面试中，前端异步解决方案是一个高频面试题，在此做一个总结回顾。\n一、首先从概念上理解，什么是同步异步？ 同步和异步是从消息通知机制来区分：\n同步表示将任务按顺序一个接一个执行，在上一个没有执行完之前不会进行下一个，调用者会得到每个任务返回值\n异步代表当前的任务如果需要一些时间和资源，调用方会返回执行下一个任务，没有返回结果，等到合适的时机再通过回调/通知继续当前的任务。\n二、js 中的异步 1 回调函数 在工作流程中我们最常用的就是通过回调函数来完成异步需求，传入指定的回调函数，当某个条件下会自动调用，比如完成一个ajax 请求:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  const xhr = new XMLHttpRequest(); xhr.open(\u0026#39;GET\u0026#39;, \u0026#39;http://localhost:8080/\u0026#39;); xhr.onreadystatechange = () =\u0026gt; { if (xhr.readyState === 4) { if (xhr.status \u0026gt;= 200 \u0026amp;\u0026amp; xhr.status \u0026lt; 300) { const res = xhr.responseText; console.log(res) } else if (xhr.status \u0026gt;= 400) { console.log(\u0026#39;失败\u0026#39;); } } } xhr.send();   js 也提供一些api 来支持异步调用，用法都是传入一个回调函数，将在指定时间之后执行该函数，比如setTimeout,setInterval,requestAnimationFrame\n1 2 3 4 5 6 7 8 9 10 11 12  setTimeout(() =\u0026gt; { console.log(\u0026#39;1秒后打印\u0026#39;) }, 1000); setInterval(() =\u0026gt; { console.log(\u0026#39;隔1秒打印\u0026#39;) }, 1000); requestAnimationFrame(()=\u0026gt;{ console.log(\u0026#39;浏览器下一次重绘之前执行\u0026#39;) })   需要注意的是，在浏览器的事件循环中，并不会在精准的到达时间调用回调，还是考虑事件循环机制，当主线程代码执行完毕，才会去消息队列中查看是否有到达时间的回调，如果主线程因为一些大量运算导致时间到达的时候还没完成，那么定时器中的回调函数会在设定的时间基础上有延迟。\nnodejs 中的异步支持回调函数，并且规定异步API 回调函数的第一个参数是错误信息\n1 2 3 4 5  const fs = require(\u0026#39;fs\u0026#39;); fs.readFile(\u0026#39;./test.txt\u0026#39;,\u0026#39;utf8\u0026#39;,function (err,data) { console.log(\u0026#39;name\u0026#39;,data); })   发布订阅 发布订阅的思想是将即将执行的函数暂存，等需要的时候触发，例如\n1 2 3  document.getElementById(\u0026#34;myBtn\u0026#34;).addEventListener(\u0026#34;click\u0026#34;, function(){ document.getElementById(\u0026#34;demo\u0026#34;).innerHTML = \u0026#34;Hello World\u0026#34;; });   是将参数函数绑定到id 为myBtn的div click 事件队列中，当点击的时候触发这个函数，不过同理要走事件循环的逻辑。\n实现一个简易的发布订阅功能：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35  class myEvent{ constructor(){ this.events = {};// 存储事件  } // 添加监听  on(eventName,fn){ if(!this.events[eventName]){ this.events[eventName] = [fn]; }else { this.events[eventName].push(fn); } } // 触发监听  emit(eventName,...args){ console.log(this.events[eventName]); if(this.events[eventName]){ this.events[eventName].forEach(fn =\u0026gt; fn(...args)); } } } const evt = new myEvent(); evt.on(\u0026#39;click\u0026#39;,(...args)=\u0026gt;{ console.log(\u0026#39;click1\u0026#39;,...args); }) evt.on(\u0026#39;click\u0026#39;,()=\u0026gt;{ console.log(\u0026#39;click2\u0026#39;); }) setTimeout(() =\u0026gt; { evt.emit(\u0026#39;click\u0026#39;,\u0026#39;1\u0026#39;,\u0026#39;2\u0026#39;); }, 1000);   promise 随着项目复杂度增加，基于回调函数的异步方案会有一些问题，比如b接口需要a接口的数据后才能发送，这时代码就需要嵌套，如果是多个请求串行，代码可能会变成\n1 2 3 4 5 6 7 8 9 10  // 假设使用jquery封装好的ajax $.ajax({ url: \u0026#34;http://localhost:8080/a\u0026#34;, success: function(resA){ // todo...  $.ajax({ url: \u0026#34;http://localhost:8080/b\u0026#34;, success: function(resB){ // toto...  $.ajax({ url: \u0026#34;http://localhost:8080/c\u0026#34;, success: function(resC){ console.log(resC) }}); }}); }});   这样的多层嵌套看起来不美观且难以理解，错误处理也需要一层层判断，于是es6标准引入promise,\npromise 支持用户传入一个executor 函数，并提供resove和reject回调，用户可以方便的在executor 函数中调用来更改promise 内部状态，当状态改变，promise.then中传入的成功和失败回调就会被依次调用，then方法返回的是一个新的Promise实例,因此promise支持链式调用，提供catch方法统一捕获错误，上面的例子可以写成\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35  // 简易封装ajax 返回promise function myFetch(method,url){ return new Promise((resolve,reject)=\u0026gt;{ const xhr = new XMLHttpRequest(); xhr.open(method, url); xhr.onreadystatechange = () =\u0026gt; { if (xhr.readyState === 4) { if (xhr.status \u0026gt;= 200 \u0026amp;\u0026amp; xhr.status \u0026lt; 300) { const res = xhr.responseText; resolve(JSON.parse(res)) } else if (xhr.status \u0026gt;= 400) { reject(\u0026#39;error\u0026#39;+xhr.status) } } } xhr.send(); }) } const promise = myFetch(\u0026#39;get\u0026#39;,\u0026#39;http://localhost:8080/a\u0026#39;); .then((resA)=\u0026gt;{ // todo ...  return myFetch(\u0026#39;get\u0026#39;,\u0026#39;http://localhost:8080/b\u0026#39;); }) .then((resB)=\u0026gt;{ // todo...  return myFetch(\u0026#39;get\u0026#39;,\u0026#39;http://localhost:8080/c\u0026#39;); }) .then((resC)=\u0026gt;{ console.log(resC) }).catch((err)=\u0026gt;{ console.log(err) })   promise 还提供了all,race 等方法来完成并发请求，竞态请求功能，在具体的业务中都能得到很好的应用。\npromsie原理上也是基于回调函数来完成异步需求，promise 也有一些缺点，比如无法取消Promise，一旦新建它就会立即执行，无法中途取消。\ngenerator \u0026lsquo;*\u0026rsquo; 和 yield 组成了Generator函数，Generator 函数是 ES6 提供的一种异步编程解决方案，与通常的函数区别有二： 1 返回值是一个迭代器 2 函数遇到yield 关键字就暂停让出执行权 ，每次调用迭代器的next()方法都会得到一个包含value和done 的对象，\n1 2 3 4 5 6 7 8 9 10 11 12  function * gen(){ yield 1; yield 2; } let it = gen(); console.log(it.next()); console.log(it.next()); console.log(it.next()); // { value: 1, done: false } // { value: 2, done: false } // { value: undefined, done: true }   值得注意的是，for\u0026hellip;of循环，扩展运算符（\u0026hellip;）、解构赋值和Array.from方法内部调用的，都是遍历器接口。这意味着，它们都可以将 Generator 函数返回的 Iterator 对象，作为参数，不用逐个调用next方法就可以得到多个返回值结果\n摘取阮一峰教程中的例子\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  function* numbers () { yield 1 yield 2 } // 扩展运算符 [...numbers()] // [1, 2]  // Array.from 方法 Array.from(numbers()) // [1, 2]  // 解构赋值 let [x, y] = numbers(); x // 1 y // 2  // for...of 循环 for (let n of numbers()) { console.log(n) }   generator 函数迭代器和暂停的特征可以在代码中灵活的控制异步流程，尤其是结合promise,在每次next()后判断如果yield返回的是promise 对象，等待该promise执行返回结果，可以达到像同步代码一样编写异步代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  function async(num){ return new Promise((resolve,reject)=\u0026gt;{ setTimeout(() =\u0026gt; { resolve(num) }, 1000); }) } function* gen(params) { let res1 = yield async(100); let res2 = yield async(200); } const iterator = gen(); let {value,done} = iterator.next(); value.then((res)=\u0026gt;{ console.log(res); let {value,done} = iterator.next(); value.then((res)=\u0026gt;{ console.log(res) }) }) // 100 // 200    async函数 ES2017 标准引入了 async 函数，\nasync 函数是 Generator 函数的语法糖。也就是说，不必自己去一步步调用迭代器的next() 方法，它内部会在运行async 函数时候自动帮你运行，而且最后返回一个promise。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  // delay 效果 async function timeout(ms) { await new Promise((resolve) =\u0026gt; { setTimeout(resolve, ms); }); } async function asyncPrint(value, ms) { await timeout(ms); console.log(value); } console.log(asyncPrint(\u0026#39;hello world\u0026#39;, 1000)); // Promise { \u0026lt;pending\u0026gt; } 返回的是promise // hello world    使用注意点\n1、 async函数内部return语句返回的值，会成为返回的promise 的then方法回调函数的参数。\n2、async函数内部抛出错误，会导致返回的 Promise 对象变为reject状态。抛出的错误对象会被catch方法回调函数接收到。\n3、async函数返回的 Promise 对象，必须等到内部所有await命令后面的 Promise 对象执行完，才会发生状态改变，除非遇到return语句或者抛出错误。\n4、如果await后面的异步操作出错，那么等同于async函数返回的 Promise 对象被reject。\n最后，摘抄自动执行器的实现原理\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  function spawn(genF) { return new Promise(function(resolve, reject) { const gen = genF(); function step(nextF) { let next; try { next = nextF(); } catch(e) { return reject(e); } if(next.done) { return resolve(next.value); } Promise.resolve(next.value).then(function(v) { step(function() { return gen.next(v); }); }, function(e) { step(function() { return gen.throw(e); }); }); } step(function() { return gen.next(undefined); }); }); }   参考 怎样理解同步异步\nECMAScript 6 入门\n","description":"","id":5,"section":"posts","tags":["前端","JavaScript"],"title":"前端异步解决方案总结","uri":"https://blog.syzh.fun/posts/hxd/front-end-async-a9c14713e59f4677b6d2d9066b32f593/"},{"content":"  问题表现: 把slice传入函数并修改, 所做的append操作在函数外会丢失\n  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  func main() { // 初始化slice  s := make([]int, 0, 10) s = append(s, 1, 2, 3) // 打印当前slice的信息  header := (*reflect.SliceHeader)(unsafe.Pointer(\u0026amp;s)) fmt.Printf(\u0026#34;main start - %v, %#v\\n\u0026#34;, s, header) // 把slice传入函数  helper(s) // 打印当前slice的信息  header = (*reflect.SliceHeader)(unsafe.Pointer(\u0026amp;s)) fmt.Printf(\u0026#34;main end - %v, %#v\\n\u0026#34;, s, header) } func helper(s []int) { // 打印刚传入时slice的信息  header := (*reflect.SliceHeader)(unsafe.Pointer(\u0026amp;s)) fmt.Printf(\u0026#34;helper start - %v, %#v\\n\u0026#34;, s, header) // 向slice中插入数据  s = append(s, 4, 5) // 打印插入数据后slice的信息  header = (*reflect.SliceHeader)(unsafe.Pointer(\u0026amp;s)) fmt.Printf(\u0026#34;helper end - %v, %#v\\n\u0026#34;, s, header) } // ===================输出====================== // 可以看到, 即使slice的地址保持不变, 在helper函数中做的修改还是丢失了. main start - [1 2 3], \u0026amp;reflect.SliceHeader{Data:0xc00001c0a0, Len:3, Cap:10} helper start - [1 2 3], \u0026amp;reflect.SliceHeader{Data:0xc00001c0a0, Len:3, Cap:10} helper end - [1 2 3 4 5], \u0026amp;reflect.SliceHeader{Data:0xc00001c0a0, Len:5, Cap:10} main end - [1 2 3], \u0026amp;reflect.SliceHeader{Data:0xc00001c0a0, Len:3, Cap:10}       问题原因\n 因为golang总是传值, slice在传入helper函数后, helper函数中的s变量是一个新的变量, append操作修改的是此局部变量的Len值. 而main函数中的s变量, 其Len值始终没有改变. 这里需要注意, 如果在helper中修改了slice中的值, 比如s[0] = 100, 这个会反映在main函数中的s变量上. 因为两个s变量共用一个底层array    避免方式\n  如果想在函数中修改原始的slice, 可以传递引用, 或是返回新的slice. 传递引用的代码如下\n  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32  func main() { // 初始化slice  s := make([]int, 0, 10) s = append(s, 1, 2, 3) // 打印当前slice的信息  header := (*reflect.SliceHeader)(unsafe.Pointer(\u0026amp;s)) fmt.Printf(\u0026#34;main start - %v, %#v\\n\u0026#34;, s, header) // 把slice的引用传入函数  helper(\u0026amp;s) // 打印当前slice的信息  header = (*reflect.SliceHeader)(unsafe.Pointer(\u0026amp;s)) fmt.Printf(\u0026#34;main end - %v, %#v\\n\u0026#34;, s, header) } // 接收引用作为参数 func helper(s *[]int) { // 打印刚传入时slice的信息  header := (*reflect.SliceHeader)(unsafe.Pointer(s)) fmt.Printf(\u0026#34;helper start - %v, %#v\\n\u0026#34;, s, header) // 向slice中插入数据  *s = append(*s, 4, 5) // 打印插入数据后slice的信息  header = (*reflect.SliceHeader)(unsafe.Pointer(s)) fmt.Printf(\u0026#34;helper end - %v, %#v\\n\u0026#34;, s, header) } //==================输出===================== main start - [1 2 3], \u0026amp;reflect.SliceHeader{Data:0xc00001c0a0, Len:3, Cap:10} helper start - \u0026amp;[1 2 3], \u0026amp;reflect.SliceHeader{Data:0xc00001c0a0, Len:3, Cap:10} helper end - \u0026amp;[1 2 3 4 5], \u0026amp;reflect.SliceHeader{Data:0xc00001c0a0, Len:5, Cap:10} main end - [1 2 3 4 5], \u0026amp;reflect.SliceHeader{Data:0xc00001c0a0, Len:5, Cap:10} \u0026lt;!-- ``` --\u0026gt;       ","description":"","id":6,"section":"posts","tags":["后端","Golang","踩坑"],"title":"Golang踩坑总结-把slice传入函数","uri":"https://blog.syzh.fun/posts/syzh/golang-pitfall-slice-as-argument/"},{"content":"本文主要是对项目构建优化过程的记录，项目是基于vue3.0脚手架搭件的\n首次打包 dist : 15.1 M\n1 发现dist/img/icons 中有很多vue-cli 自带的vue-icon ，将pubic/img/icon 文件夹删除 ​ img中的favicon.icon 可以换成自己网站的favicon.icon(4k)\n​ 再次打包： 15M\n2 速度分析 我们的目的是优化打包速度，那肯定需要一个速度分析插件，此时 speed-measure-webpack-plugin 就派上用场了。它的作用如下：\n 分析整个打包总耗时 每个 plugin 和 loader 的耗时情况  首先，安装插件\n1  npm i -D speed-measure-webpack-plugin   然后修改 vue.config.js 配置文件\n1 2 3 4 5 6 7 8 9 10 11 12  // 导入速度分析插件 const SpeedMeasurePlugin = require(\u0026#34;speed-measure-webpack-plugin\u0026#34;); // 实例化插件 const smp = new SpeedMeasurePlugin(); module.exports = { configureWebpack: smp.wrap({ plugins: [ // 这里是自己项目里需要使用到的其他插件  // new yourOtherPlugin()  ] }) }   打包后总耗时 38.28 secs ，也可以看到各个loader 打包所耗费时间\n3 取消生产环境生成map文件 1  devtool: \u0026#39;#eval-source-map\u0026#39;,//映射js到原文件   由于打包后的js调试不方面，所以应用此，自动映射报错到原文件.\n看到生成的js文件件中有很多.js.map 文件，应该在生产环境去除，以加速生产环境构建，缩小体积\n1  productionSourceMap: false   再次打包： 25.93 secs dist 4.4M\n4 为了防止dist 目录文件越来越多，每次都要手动清楚dist 文件夹，比较麻烦 clean-webpack-plugin 默认每次打包前删除output.path 文件夹\n5 一直都有的warning 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  The following asset(s) exceed the recommended size limit (244 KiB). This can impact web performance. 以下文件超出了建议的大小 img/ionicons.a2c4a261.svg (542 KiB) css/chunk-vendors.d48681d6.css (583 KiB) js/chunk-vendors.7a36829a.js (1.8 MiB) js/main.42b88c10.js (527 KiB) entrypoint size limit: The following entrypoint(s) combined asset size exceeds the recommended limit (244 KiB). This can impact web performance. 入口文件以及相关的资源大小超过了建议的244k Entrypoints: app (2.41 MiB) ​ css/chunk-vendors.d48681d6.css ​ js/chunk-vendors.7a36829a.js ​ css/app.15a328ee.css ​ js/app.cbb3c76a.js   查看main.ts 觉得引入的内容过多，但是具体的打包情况不清楚，由此引入webpack-bundle-analyzer 插件来进行体积分析\n1  npm i -D webpack-bundle-analyzer   打包后可以看到node_modules 中的内容达到了5.43M,其他内容1.11M （未压缩）\n其中node_modules chunk-vendor.js 中最大的是elementui\n发现有很多动态加载的路由组件没有写明 webpackChunkName 导致单独打包了，而且其他动态加载的都叫main,导致打包的动态加载main.JS 过大\n优化： 将动态加载的模块根据功能块分为 order list user\n再次打包 没有过大的main.js 以及一些匿名的chunk ,打包时间18.69 secs 但还是有一些警告：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  asset size limit: The following asset(s) exceed the recommended size limit (244 KiB). This can impact web performance. Assets: img/ionicons.a2c4a261.svg (542 KiB) css/chunk-vendors.d48681d6.css (583 KiB) js/chunk-vendors.aefb80b0.js (1.8 MiB) js/list~order~user.7ae80867.js (396 KiB) warning entrypoint size limit: The following entrypoint(s) combined asset size exceeds the recommended limit (244 KiB). This can impact web performance. Entrypoints: app (2.41 MiB) ​ css/chunk-vendors.d48681d6.css ​ js/chunk-vendors.aefb80b0.js ​ css/app.15a328ee.css ​ js/app.a09ad1ae.js   警告是因为默认配置中提供了这些限制\nhttps://cli.vuejs.org/zh/guide/build-targets.html#%E5%BA%94%E7%94%A8 中给出了默认的打包策略\n@vue\\cli-service\\lib\\config\\prod.js 这里是cli中的默认配置，可以根据需要查看\n发现 第三方库会被分到一个独立包以便更好的缓存（也就是比较大的chunk-vendors.）,为了更快的加载，决定提取比较大的element\n在我们的项目中要引入很多的第三方组件库例如element-ui，还有公司内部的一些组件库，如果我们使用默认配置不做任何修改，vendors缓存组中的内容会很多，页面引用时耗时就会较长，所以将缓存组中的内容进行拆分是很有必要的。\n例如我们将element-ui分割成一个独立的chunk，cacheGroups中配置如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  configureWebpack: smp.wrap({ plugins: [ // 这里是自己项目里需要使用到的其他插件  // new yourOtherPlugin()  new CleanWebpackPlugin(), new BundleAnalyzerPlugin() ], optimization: { //注意这里要写到configureWebpack: smp.wra 内部  splitChunks: { cacheGroups:{ elementUI: { priority: 20, name: \u0026#34;elementUI\u0026#34;, test: /element-ui/, reuseExistingChunk: true, chunks: \u0026#39;initial\u0026#39; } } } } })   再次打包： 都在500k 之内，用时17.43 secs dist 4.4M 如果觉得不好，还可以继续抽取某个模块出来\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33  dist/js/chunk-vendors.f6665299.js 1187.85 KiB 410.17 KiB dist/js/elementUI.8d715862.js 651.54 KiB 161.19 KiB dist/js/list~order~user.7ae80867.js 396.42 KiB 109.46 KiB dist/js/list.4bae4c4a.js 73.11 KiB 20.93 KiB dist/js/order.d53d6a7b.js 56.50 KiB 11.95 KiB dist/js/user.960bd4f6.js 52.52 KiB 10.88 KiB dist/js/app.7a5d9e33.js 30.20 KiB 8.92 KiB dist/precache-manifest.b90139ea6a8765f 2.58 KiB 0.81 KiB 806da9c48a2db3e60.js dist/service-worker.js 0.95 KiB 0.54 KiB dist/css/chunk-vendors.2451089e.css 347.71 KiB 50.92 KiB dist/css/elementUI.cb02cf65.css 235.19 KiB 34.85 KiB dist/css/user.59bdb936.css 19.23 KiB 5.49 KiB dist/css/order.480f9cfb.css 18.01 KiB 2.18 KiB dist/css/list.752f1f66.css 17.29 KiB 2.54 KiB dist/css/app.15a328ee.css 11.20 KiB 5.32 KiB dist/css/list~order~user.c0f64a3d.css 4.94 KiB 1.06 KiB   关于打包结果的提示： 可以配置：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  module.exports = { //webpack配置  configureWebpack: { //关闭 webpack 的性能提示  performance: { hints:false } //或者 修改提示阙值  //警告 webpack 的性能提示  performance: { hints:\u0026#39;warning\u0026#39;, //入口起点的最大体积  maxEntrypointSize: 50000000, //生成文件的最大体积  maxAssetSize: 30000000, //只给出 js 文件的性能提示  assetFilter: function(assetFilename) { return assetFilename.endsWith(\u0026#39;.js\u0026#39;); } } }   6 尝试用compression-webpack-plugin 对代码再次压缩，不过需要配置服务器就没有采用了 1 2 3 4 5 6 7 8 9  const productionGzipExtensions = /\\.(js|css)$/i; new CompressionPlugin({ filename: \u0026#39;[path].gz[query]\u0026#39;, algorithm: \u0026#39;gzip\u0026#39;, test: productionGzipExtensions, threshold: 10240, minRatio: 0.8, deleteOriginalAssets: true }),   7 提高构建速度 HardSourceWebpackPlugin 为模块提供中间缓存，缓存默认的存放路径是: node_modules/.cache/hard-source。\n配置 hard-source-webpack-plugin，首次构建时间没有太大变化，但是第二次开始，构建时间大约可以节约 80%。\n1 2 3 4 5 6 7 8  //webpack.config.js var HardSourceWebpackPlugin = require(\u0026#39;hard-source-webpack-plugin\u0026#39;); module.exports = { //...  plugins: [ new HardSourceWebpackPlugin() ] }   使用后打包时间第一次30多秒，之后都差不多为8、9秒。\n","description":"","id":7,"section":"posts","tags":["前端","webpack"],"title":"webpack项目打包优化","uri":"https://blog.syzh.fun/posts/hxd/webpack-optimization/"},{"content":"本文对于webpack 编译出的内容做分析总结。\n普通文件引入的打包 1 2  // src/test.js module.exports = \u0026#39;test\u0026#39;   1 2 3  // src/index.js let test = require(\u0026#39;./test\u0026#39;); console.log(test)   打包后的main.js(摘取部分)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36  // 打包入口 ./src/index.js (function (modules) { var installedModules = {}; function __webpack_require__(moduleId) { // 缓存作用，如果已经引入过了，使用引入过的结果  if (installedModules[moduleId]) { return installedModules[moduleId].exports; } var module = installedModules[moduleId] = { i: moduleId, l: false, exports: {} }; modules[moduleId].call(module.exports, module, module.exports, __webpack_require__); module.l = true; return module.exports; } return __webpack_require__(__webpack_require__.s = \u0026#34;./src/index.js\u0026#34;); }) ({ // 包装成一个模块对象 绝对路径对应这个模块  \u0026#34;./src/index.js\u0026#34;: (function (module, exports, __webpack_require__) { // 将代码中的require -\u0026gt;__webpack_require__ t console.log(test) }), \u0026#34;./src/test.js\u0026#34;: (function (module, exports) { module.exports = \u0026#39;test\u0026#39; }) });   在我理解看来，在打包的过程中，每个模块被封装成了一个函数，此时模块代码并没有被执行，而是被放在了打包文件自执行函数的参数modules 中，从这个自执行函数的末尾\n1  return __webpack_require__(__webpack_require__.s = \u0026#34;./src/index.js\u0026#34;);   开始，根据入口文件引用的文件逐一运行，原文件中的require 被替代成__webpack_require__，也就是说，webpack打包的文件都没有使用node/es6的引用方法，而是自己实现的__webpack_require__方法。\n从__webpack_require__('./src/index.js')开始，拿到参数modules中被包装的index.js 的内容，遇到__webpack_require__('./src/test.js') 时，运行参数modules中./src/test.js 对应的封装方法，每运行完一个模块，就会为其生成一个module对象添加到installedModules，{ i: moduleId, l: false, exports:{}},保存其路径i，导出的内容exports，标记是否已经加载过l,installedModules 可以起到缓存的作用，如果已经加载过的模块可以直接从installedModules里拿到。\n不同引入方法的打包 众所周知，目前比较流行的模块加载方式是nodejs的module.exports/require 以及es6的 import/export,在webpack中这两种打包方式都支持，也就是上文中的__webpack_require__ 两种都支持，尝试通过es6 将上例中的test.js 修改成\n1 2  // src/test.js export const test = \u0026#39;test\u0026#39;   打包后的main.js(摘取部分)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61  (function(modules) { // webpackBootstrap  // The module cache  var installedModules = {}; // The require function  function __webpack_require__(moduleId) { if(installedModules[moduleId]) { return installedModules[moduleId].exports; } var module = installedModules[moduleId] = { i: moduleId, l: false, exports: {} }; modules[moduleId].call(module.exports, module, module.exports, __webpack_require__); module.l = true; return module.exports; } __webpack_require__.m = modules; __webpack_require__.c = installedModules; __webpack_require__.d = function(exports, name, getter) { if(!__webpack_require__.o(exports, name)) { Object.defineProperty(exports, name, { enumerable: true, get: getter }); } }; __webpack_require__.r = function(exports) { if(typeof Symbol !== \u0026#39;undefined\u0026#39; \u0026amp;\u0026amp; Symbol.toStringTag) { Object.defineProperty(exports, Symbol.toStringTag, { value: \u0026#39;Module\u0026#39; }); } Object.defineProperty(exports, \u0026#39;__esModule\u0026#39;, { value: true }); }; __webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); }; return __webpack_require__(__webpack_require__.s = \u0026#34;./src/index.js\u0026#34;); }) ({ \u0026#34;./src/index.js\u0026#34;: (function(module, exports, __webpack_require__) { let test = __webpack_require__(\u0026#34;./src/test.js\u0026#34;); console.log(test) }), \u0026#34;./src/test.js\u0026#34;: (function(module, __webpack_exports__, __webpack_require__) { __webpack_require__.r(__webpack_exports__); __webpack_require__.d(__webpack_exports__, \u0026#34;test\u0026#34;, function() { return test; }); const test = \u0026#39;test\u0026#39; }) });   可以看出，与上例中最大的区别是包装test.js 发生了变化，去除了export 关键字，并且添加了\n__webpack_require__.r(__webpack_exports__); __webpack_require__.d(__webpack_exports__, \u0026quot;test\u0026quot;, function() { return test; }); 查看__webpack_require__.r方法，发现是向模块运行结果exports中添加标记，标记当前模块__esModule 为true,如果是支持\nSymbol的浏览器，也添加一个Symbol值为Module，这种标记是为了后续有需要的地方可以识别此模块的导出方式，__webpack_require__.d 方法则是为当前导出的exports 对象上添加一个值为\u0026rsquo;test\u0026rsquo;的test 属性，如此一来，test.js 也有了module.exports = {test: \u0026lsquo;test\u0026rsquo;}的效果。\n同理，其他导出/导入组合，webpack 都会对包装函数做不同的处理，以便能统一达到效果。\n","description":"","id":8,"section":"posts","tags":["前端","webpack"],"title":"webpack 学习总结 三","uri":"https://blog.syzh.fun/posts/hxd/webpack-notes-3/"},{"content":"上一篇总结了webpack中使用的一些库，这一篇来总结下webpack整体流程,主要根据代码流程来总结。\n","description":"","id":9,"section":"posts","tags":["前端","webpack"],"title":"webpack 学习总结 二","uri":"https://blog.syzh.fun/posts/hxd/webpack-notes-2/"},{"content":"webpack 是当前前端项目打包当中非常流行的打包框架，结合丰富的流程钩子函数、插件系统以及nodejs部分功能 给开发者提供了方便配置，易于扩展的打包工具，在学习webpack源码流程(4.43.0)的这段时间收获很多，在此做一些总结。\n本文首先总结下，在webpack中用到的诸多工具项目，他们在实现整体流程中起到了很大的作用。\n一 Tapable Tapable是webpack流程的基础，整个编译过程，各个模块的方法调用都是基于Tapable的事件注册和触发。相对于nodejs 的EventEmitter，Tapable提供了事件触发的更多形式，同步触发，异步并行触发，异步串行触发等等，可以满足不同需求。\n在webapck中，最主要的Compiler和Compilation类都继承了\nTapable，从而可以生成自己的一系列钩子函数，这些钩子函数在流程控制中起到承上启下的作用，也为开发者自定义功能提供了灵活的接口。\n官网中的例子：\nconst { SyncHook, AsyncParallelHook, } = require(\u0026quot;tapable\u0026quot;); class Car { constructor() { this.hooks = { accelerate: new SyncHook([\u0026quot;newSpeed\u0026quot;]), brake: new SyncHook(), calculateRoutes: new AsyncParallelHook([\u0026quot;source\u0026quot;, \u0026quot;target\u0026quot;, \u0026quot;routesList\u0026quot;]) }; } /* ... */ } const myCar = new Car(); // 相当于给brake钩子添加一个事件（此时并不会执行，可以添加多个） myCar.hooks.brake.tap(\u0026quot;WarningLampPlugin\u0026quot;, () =\u0026gt; warningLamp.on()); // 触发钩子函数,可以在需要的时机来触发，webpack中正是利用这一点来统一给各流程添加逻辑 myCar.hooks.brake.call() 二 neo-async neo-async 其中的forEach 方法可以方便的进行异步循环，循环结束后执行回调,在webpack中处理模块依赖时需要用到该方法来确保在模块的所有依赖处理完成之后进行下一步。\n// array var order = []; var array = [1, 3, 2]; var iterator = function(num, done) { setTimeout(function() { order.push(num); done(); }, num * 10); }; async.each(array, iterator, function(err, res) { console.log(res); // undefined console.log(order); // [1, 2, 3] }); 三 Semaphore Semaphore\n是一个控制并发数量的工具，可以设置最大并发量，在任务结束时释放容量，每次take 一个任务时都会查看是否到达容量极限，如果到达会存储任务到队列中，等待容量被释放时再从队列中取出任务执行\n// 2 clients at a time var sem = require('semaphore')(2); var server = require('http').createServer(req, res) { res.write(\u0026quot;Then good day, madam!\u0026quot;); sem.take(function() { res.end(\u0026quot;We hope to see you soon for tea.\u0026quot;); sem.leave(); }); }); webpack中工厂函数生成多个模块 以及编译模块时都采用了\nSemaphore 来控制并发\n四 利用Object.defineProperty 重写get函数来添加一些内容获取的逻辑 let test = {arr: [1,2,2,3,4,5] } let res = {} Object.defineProperty(res, 'arr', { get() { // 这里可以自由添加自己需要的逻辑 return test.arr.filter(item=\u0026gt;item\u0026gt;1); } }); console.log(res.arr)// [2, 2, 3, 4, 5] webpack 中LoaderRunner.js 中就采用了这一技巧对loader进行信息采集\n","description":"","id":10,"section":"posts","tags":["前端","webpack"],"title":"webpack 学习总结 一","uri":"https://blog.syzh.fun/posts/hxd/webpack-notes-1/"},{"content":"  程序执行到defer语句的时候, 被defer的函数的实参会在此时被求值\n  1 2 3 4 5 6 7 8 9 10  func a() { i := 0 // 被defer的函数实参会在此时被求值, 这里为0  defer fmt.Println(i) // i自增, 但不会影响defer的函数  i++ return } //===========输出=========== 0       被defer的函数调用, 执行顺序是\u0026quot;后进先出\u0026quot;\n  defer的函数调用会被压入一个栈中。当外层函数返回时，被推迟的函数会按照后进先出的顺序调用。\n  如果函数的返回值是命名的, defer语句中的函数可以读取或修改该值\n  1 2 3 4 5 6 7 8 9  // 修改命名的返回值 func c() (i int) { // 在defer语句中自增  defer func() { i++ }() // 这里i被设为1  return 1 } //=============输出============ 2     1 2 3 4 5 6 7 8  // 返回值是匿名的, 无法被defer修改 func c() int { i := 1 defer func() { i++ }() return i } //=============输出============ 1       实参估值和修改返回变量的例子\n  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  func test() (x int) { // defer语句的实参会被立刻估值, 因此实参x==0  defer func(n int) { // 实参x估值为0, 因此形参n==0  fmt.Printf(\u0026#34;in defer x as parameter: x = %d\\n\u0026#34;, n) // 这里的x是外面的x, 因此为9  fmt.Printf(\u0026#34;in defer x after return: x = %d\\n\u0026#34;, x) }(x) x = 7 // x==9  return 9 } // =============执行结果============== in defer x as parameter: x = 0 in defer x after return: x = 9       最好在获取资源之后, 立刻调用defer\n  defer在其所在的函数的末尾执行, 因此在for循环中使用时要注意\n  1 2 3 4 5 6 7 8 9 10  // 有问题的写法 for _, filename := range filenames { f, err := os.Open(filename) if err != nil { return err } // 释放资源的操作直到所在函数末尾才执行, 如果文件很多, 可能导致文件描述符用尽  defer f.Close() // 处理文件 }     1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  // 改进写法 for _, filename := range filenames { if err := doFile(filename); err != nil { return err } } // 抽取处理单个文件的逻辑, 此函数返回时即可关闭文件 func doFile(filename string) error { f, err := os.Open(filename) if err != nil { return err } defer f.Close() // 处理文件 }       ","description":"","id":11,"section":"posts","tags":["后端","Golang"],"title":"Golang defer语句用法小结","uri":"https://blog.syzh.fun/posts/syzh/golang-defer/"},{"content":"  sync包提供传统的内存访问的同步机制\n  WaitGroup\n  等待若干goroutine执行完毕\n  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33  // 注意: 如果wg是在闭包环境中使用, 由于闭包中捕获的是变量本身, 因此直接使用wg变量即可. 但如果是下面代码这样, 作为函数的参数调用, 则需要传引用来保证使用的是同一个wg  // 传入公用的wg对象 hello := func(wg *sync.WaitGroup, id int) { // 执行完成后, 内部值-1  defer wg.Done() fmt.Printf(\u0026#34;Hello from %v!\\n\u0026#34;, id) } // 定义goroutine数量 const numGreeters = 5 // 初始化waitgroup var wg sync.WaitGroup // 一次性增加内部值, 也可以在for语句中逐个增加 wg.Add(numGreeters) for i := 0; i \u0026lt; numGreeters; i++ { // wg.Add(1) 如果使用逐个增加的方式  go hello(\u0026amp;wg, i+1) } // 阻塞, 直到内部值变为0 wg.Wait() //===========输出=============== // 顺序不确定 Hello from 1! Hello from 5! Hello from 2! Hello from 3! Hello from 4!       Mutex and RWMutex\n  保护关键区域(guard critical sections)\n  Mutex\n  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  var count int var lock sync.Mutex // 下面两个函数都是线程安全的 increment := func() { lock.Lock() // 使用defer, 确保锁被释放  defer lock.Unlock() count++ fmt.Printf(\u0026#34;Incrementing: %d\\n\u0026#34;, count) } decrement := func() { lock.Lock() defer lock.Unlock() count-- fmt.Printf(\u0026#34;Decrementing: %d\\n\u0026#34;, count) }       RWMutex\n  可以同时有任意多个读锁, 或一个写锁\n  读锁是共享的, 写锁是排他的\n  1 2 3 4 5 6 7 8 9 10 11 12 13 14  var mu sync.RWMutex var balance int func Balance() int { mu.RLock() // readers/shared lock  defer mu.RUnlock() return balance } func Deposit(amount int) { mu.Lock() // // writer/exclusive lock  defer mu.Unlock() balance += amount }         Cond\n  在某个点等待某事件(event)的发生, 在此之前保持阻塞/挂起状态, 使其他goroutine可以执行\n  用于notify的方法\n Signal: 通知等待最久的goroutine, 这个功能也可以用channel实现  runtime维护了一个FIFO保存等待通知的goroutine, 因此会通知等待最久的goroutine   Broadcast: 通知所有goroutine, 这个功能用channel不好实现    性能比使用channel实现好很多\n  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38  // 假设我们有一个固定len为2的queue, 我们想加入10个元素进去. 我们希望queue一有多余的空间, 就能通知我们, 让我们插入新的元素  // 创建一个cond, 需要传入一个sync.Locker来保护关键区域 c := sync.NewCond(\u0026amp;sync.Mutex{}) // 初始化queue queue := make([]interface{}, 0, 10) // dequeue函数 removeFromQueue := func(delay time.Duration) { // sleep delay的时间  time.Sleep(delay) // 使用lock保护关键区域  c.L.Lock() // dequeue  queue = queue[1:] fmt.Println(\u0026#34;Removed from queue\u0026#34;) // unlock, 离开关键区域  c.L.Unlock() // 通知等待最久的goroutine, 也可以用broadcast来通知所有  c.Signal() } for i := 0; i \u0026lt; 10; i++ { // 进入关键区域  c.L.Lock() // 需要使用for循环来检查条件. 因为接到通知并不一定意味着我们在等待的事情已经发生, 所以需要再次检查条件  for len(queue) == 2 { // 在内部会先调用unlock, 然后等待. 接到通知继续执行后, 会调用lock  c.Wait() } fmt.Println(\u0026#34;Adding to queue\u0026#34;) // enqueue  queue = append(queue, struct{}{}) // 启动goroutine, 1s后执行dequeue  go removeFromQueue(1 * time.Second) // 离开关键区域  c.L.Unlock() }       Once\n  每个sync.Once的对象, 只能调用1次Do方法, 之后的对Do的调用无效.\n  1 2 3 4 5 6 7 8 9 10 11 12  var count int increment := func() { count++ } decrement := func() { count-- } var once sync.Once // 第一次调用Do方法, 有效 once.Do(increment) // 此次调用Do方法无效 once.Do(decrement) fmt.Printf(\u0026#34;Count: %d\\n\u0026#34;, count) // count为1, once对象只能执行一次DO方法       Pool\n  创建一个对象池, 其中的对象可以复用(比如数据库连接), 且是线程安全的\n  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  myPool := \u0026amp;sync.Pool{ // 生成新对象  New: func() interface{} { fmt.Println(\u0026#34;Creating new instance.\u0026#34;) return struct{}{} }, } // pool是空的, 因此会创建新对象 myPool.Get() // 上面创建的对象没有被放回, 因此现在pool中还是空的 // 由于pool是空的, 因此会创建新对象 instance := myPool.Get() // 放回对象, 经常配合defer使用 myPool.Put(instance) // 由于pool中有对象, 因此不会创建新对象 myPool.Get() //============输出============ Creating new instance. Creating new instance.       ","description":"","id":12,"section":"posts","tags":["后端","Golang","GoSync"],"title":"Golang sync包用法小结","uri":"https://blog.syzh.fun/posts/syzh/golang-sync/"},{"content":"提供了Golang交替打印的几个思路: 使用Goroutine, sync包中的WaitGroup和Cond\n  使用unbuffered channel实现\n  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36  func PrintABUnbufferedChannel() { // 使用2个channel实现交替运行  c1 := make(chan struct{}) c2 := make(chan struct{}) // 打印aaa的函数, 对2个channel执行send操作  PrintA := func() { for { c1 \u0026lt;- struct{}{} fmt.Println(\u0026#34;aaa\u0026#34;) time.Sleep(1 * time.Second) c2 \u0026lt;- struct{}{} } } // 打印bbb的函数, 对2个channel执行receive操作  PrintB := func() { for { \u0026lt;-c2 fmt.Println(\u0026#34;bbb\u0026#34;) time.Sleep(1 * time.Second) \u0026lt;-c1 } } // 先打印aaa  go func() { \u0026lt;-c1 }() go PrintA() go PrintB() time.Sleep(1 * time.Hour) }       使用sync.Cond配合sync.WaitGroup实现\n  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54  func PrintABCond() { // 使用2个cond实现交替运行  c1 := sync.NewCond(\u0026amp;sync.Mutex{}) c2 := sync.NewCond(\u0026amp;sync.Mutex{}) // 使用waitgroup协调顺序, 确保printA, printB先启动, 再发送第一个signal  var wg sync.WaitGroup // 打印aaa的函数, 等待c1, 通知c2  printA := func() { // 确保printA启动早于第一个signal  wg.Done() for { c1.L.Lock() // 等待信号  c1.Wait() fmt.Println(\u0026#34;aaa\u0026#34;) time.Sleep(1 * time.Second) // 发送信号  c2.Signal() c1.L.Unlock() } } // 打印bbb的函数, 等待c2, 通知c1  printB := func() { // 确保printB启动早于第一个signal  wg.Done() for { c2.L.Lock() // 等待信号  c2.Wait() fmt.Println(\u0026#34;bbb\u0026#34;) time.Sleep(1 * time.Second) // 发送信号  c1.Signal() c2.L.Unlock() } } wg.Add(2) // 先打印aaa  go func() { // 等待printA, printB启动后, 再发送第一个signal  wg.Wait() c1.Signal() }() go printA() go printB() time.Sleep(1 * time.Hour) }       使用for-select语句实现, 与方法1类似\n  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  func PrintABForSelect() { c1 := make(chan struct{}) c2 := make(chan struct{}) printAB := func() { for { select { case \u0026lt;-c1: fmt.Println(\u0026#34;aaa\u0026#34;) time.Sleep(1 * time.Second) c2 \u0026lt;- struct{}{} case \u0026lt;-c2: fmt.Println(\u0026#34;bbb\u0026#34;) time.Sleep(1 * time.Second) c1 \u0026lt;- struct{}{} } } } go func() { c1 \u0026lt;- struct{}{} }() go printAB() go printAB() time.Sleep(1 * time.Hour) }       ","description":"","id":13,"section":"posts","tags":["后端","Golang","Goroutine","GoChannel","GoSync"],"title":"Golang交替打印的几种实现方式","uri":"https://blog.syzh.fun/posts/syzh/golang-goroutine-coordinate/"},{"content":"三色标记-清除算法(tricolor mark-and-sweep algorithm)\n 把heap中的对象, 用黑色, 灰色, 白色进行标记  黑色对象: 已经以其为root执行过可达性分析的对象 灰色对象: 需要但还未以其为root执行过可达性分析的对象 白色对象: 从gc root无法被触达的对象, 可能被垃圾回收   垃圾回收过程  垃圾回收开始时, 所有对象都是白色. 所有root对象被标记为灰色. root对象指程序可以直接访问的对象, 包含全局变量, 位于栈上的数据. 垃圾回收器选择一个灰色对象, 把它标记为黑色, 寻找其可以触达的白色对象, 并把它们标记为灰色. 直到把所有灰色对象都处理过一遍 此时的白色对象说明无法被触达, 因此可以被垃圾回收 如果在垃圾回收过程中, 某个灰色对象变得不可触达了, 则它会在下次垃圾回收时被清理   标记过程中, 执行中的应用程序被称为mutator, mutator有一个函数write barrier. 当heap中的某个对象被修改了, 说明该对象可被触达, 则write barrier会把此对象标记为灰色 当某channel无法被触达时, 即使其未被close, 也会被垃圾回收, 清理其占用的资源 手动触发GC: runtime.GC(), 此操作会阻塞调用者, 并可能阻塞整个程序 mark阶段, 标记对象; 没有灰色对象后, 开始sweep阶段 go的垃圾回收是与其他goroutine并发执行的  ","description":"","id":14,"section":"posts","tags":["后端","Golang","垃圾回收"],"title":"Golang垃圾回收-三色算法概览","uri":"https://blog.syzh.fun/posts/syzh/golang-garbage-collector-tricolor/"},{"content":"  问题表现\n  使用下标获取字符串的字符时, 可能得到奇怪的字符\n  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  func main() { s := \u0026#34;hello\u0026#34; fmt.Printf(\u0026#34;%c\\n\u0026#34;, s[1]) s = \u0026#34;你好\u0026#34; fmt.Printf(\u0026#34;%c\\n\u0026#34;, s[1]) } //============输出===========  e ½       问题原因\n golang是以utf8格式保存字符串的, 字符串的下标操作, 访问的是字节, 而不是字符. len函数输出的也是字节数, 如len(\u0026quot;hello\u0026quot;)==5, len(\u0026quot;你好\u0026quot;)==6    避免方式\n  把字符串转化为[]rune/[]int32, 或者使用range遍历\n  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  func main() { s := \u0026#34;你好\u0026#34; // 强转为[]rune  fmt.Printf(\u0026#34;%c\\n\u0026#34;, []rune(s)[1]) fmt.Println() // 使用range遍历  for _, c := range s { fmt.Printf(\u0026#34;%c\\n\u0026#34;, c) } } //===============输出=================  好 你 好       ","description":"","id":15,"section":"posts","tags":["后端","Golang","踩坑"],"title":"Golang踩坑总结-使用下标获取字符串的字符","uri":"https://blog.syzh.fun/posts/syzh/golang-pitfall-string-subscript/"},{"content":"  问题表现\n  goroutine中捕获的循环变量, 都为循环最后的值\n  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  func main() { for i, v := range []string{\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;, \u0026#34;d\u0026#34;, \u0026#34;e\u0026#34;} { // goroutine中捕获循环变量  go func() { fmt.Printf(\u0026#34;index: %v, value: %v\\n\u0026#34;, i, v) }() } // 此处应该使用waitgroup实现, 为了简单使用了sleep  time.Sleep(1 * time.Second) } //================输出==============  index: 4, value: e index: 4, value: e index: 4, value: e index: 4, value: e index: 4, value: e       问题原因\n goroutine中捕获的不是\u0026quot;值\u0026quot;, 而是\u0026quot;有地址的变量\u0026quot;. for循环可能会先结束, 之后各个goroutine才开始执行. 因此得到的是变量的最终值    避免方式\n  在goroutine启动的函数中, 把变量作为参数捕获\n  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  func main() { for i, v := range []string{\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;, \u0026#34;d\u0026#34;, \u0026#34;e\u0026#34;} { // 把循环变量作为参数传入  go func(i int, v string) { // i, v是函数内部的局部变量  fmt.Printf(\u0026#34;index: %v, value: %v\\n\u0026#34;, i, v) }(i, v) } time.Sleep(1 * time.Second) } //================输出==============  index: 0, value: a index: 1, value: b index: 4, value: e index: 3, value: d index: 2, value: c       ","description":"","id":16,"section":"posts","tags":["后端","Golang","踩坑","Goroutine"],"title":"Golang踩坑总结-循环中使用Goroutine中捕获参数","uri":"https://blog.syzh.fun/posts/syzh/golang-pitfall-for-goroutine/"},{"content":"  问题表现\n  闭包中捕获的循环变量, 都为循环最后的值\n  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  func main() { // 保存函数闭包  var s []func() for i, v := range []string{\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;, \u0026#34;d\u0026#34;, \u0026#34;e\u0026#34;} { s = append(s, func() { // 捕获i, v, 保存在闭包中  fmt.Printf(\u0026#34;index: %v, value: %v\\n\u0026#34;, i, v) }) } for _, f := range s { f() } } // ====================输出===========================  index: 4, value: e index: 4, value: e index: 4, value: e index: 4, value: e index: 4, value: e       问题原因\n 闭包中捕获的不是\u0026quot;值\u0026quot;, 而是\u0026quot;有地址的变量\u0026quot;. 最终执行时, 根据变量寻址, 得到的是变量最后的值    避免方式\n  在循环中, 重新声明要捕获的变量. 由于是单个循环的局部变量, 在其作用域结束前, 会进行evaluate\n  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  func main() { // 保存函数闭包  var s []func() for i, v := range []string{\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;, \u0026#34;d\u0026#34;, \u0026#34;e\u0026#34;} { // 重新声明要捕获的变量  i, v := i, v s = append(s, func() { // 捕获i, v, 保存在闭包中  fmt.Printf(\u0026#34;index: %v, value: %v\\n\u0026#34;, i, v) }) } for _, f := range s { f() } } // ====================输出===========================  index: 0, value: a index: 1, value: b index: 2, value: c index: 3, value: d index: 4, value: e       ","description":"","id":17,"section":"posts","tags":["后端","Golang","踩坑","闭包"],"title":"Golang踩坑总结-循环中使用闭包捕获参数","uri":"https://blog.syzh.fun/posts/syzh/golang-pitfall-for-closure/"},{"content":"  问题表现\n  具体类型的nil值, 赋值给接口值变量后, 被判定不为nil\n  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  func main() { // *bytes.Buffer, 零值为nil  var b *bytes.Buffer if b == nil { fmt.Println(\u0026#34;外面的b等于nil\u0026#34;) } else { fmt.Println(\u0026#34;外面的b不等于nil\u0026#34;) } f := func(b io.Writer) { if b == nil { fmt.Println(\u0026#34;里面的b等于nil\u0026#34;) } else { fmt.Println(\u0026#34;里面的b不等于nil\u0026#34;) } } // 把b传入函数  f(b) } //===========输出===============  外面的b等于nil 里面的b不等于nil       问题原因\n golang中的接口值, 除了有自己的类型type外, 还有动态类型(dynamic type)和动态值(dynamic value). 接口值如果要被判断为nil, 需要动态类型和动态值都为nil. 可以通过fmt的\u0026quot;%T\u0026quot;, \u0026ldquo;%v\u0026quot;观察动态类型和动态值    打印动态类型和动态值\n  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38  func main() { var b *bytes.Buffer fmt.Printf(\u0026#34;外面的b类型为%T\\n\u0026#34;, b) fmt.Printf(\u0026#34;外面的b值为%v\\n\u0026#34;, b) if b == nil { fmt.Println(\u0026#34;外面的b等于nil\u0026#34;) } else { fmt.Println(\u0026#34;外面的b不等于nil\u0026#34;) } fmt.Println(\u0026#34;\u0026#34;) f := func(b io.Writer) { fmt.Printf(\u0026#34;里面的b类型为%T\\n\u0026#34;, b) fmt.Printf(\u0026#34;里面的b值为%v\\n\u0026#34;, b) if b == nil { fmt.Println(\u0026#34;里面的b等于nil\u0026#34;) } else { fmt.Println(\u0026#34;里面的b不等于nil\u0026#34;) } } f(b) } //==============输出=================  外面的b类型为*bytes.Buffer 外面的b值为\u0026lt;nil\u0026gt; 外面的b等于nil 里面的b类型为*bytes.Buffer 里面的b值为\u0026lt;nil\u0026gt; 里面的b不等于nil       ","description":"","id":18,"section":"posts","tags":["后端","Golang","踩坑"],"title":"Golang踩坑总结-接口值是否等于nil","uri":"https://blog.syzh.fun/posts/syzh/golang-pitfall-interface-value-nil/"},{"content":"最近在用Golang搭建博客后端时, 遇到一个问题: 数据在从mysql到接口输出的json转化中, 需要做字段映射. 常规的方法是写db tag和json tag, 自动进行转换. 这种方式有点麻烦, 尤其struct和字段多起来的时候. 我的场景是mysql字段为snake_case, struct为CamelCase, json字段为snake_case, 就想着用代码来完成转换\n代码示例如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46  // 博客文章struct type Post struct { Content string Cover string CreatedAt time.Time FamilyID int ID int Slug string Status int Title string UpdatedAt time.Time } // struct和json互转 var keyMatchRegex = regexp.MustCompile(`\u0026#34;\\w+\u0026#34;:`) var wordBarrierRegex = regexp.MustCompile(`([a-z])([A-Z])`) // 重写Response类型的MarshalJSON方法 func (resp Response) MarshalJSON() ([]byte, error) { // 创建此类型, 防止递归  type Response_ Response marshalled, err := json.Marshal(Response_(resp)) // 正则替换  converted := keyMatchRegex.ReplaceAllFunc( marshalled, func(match []byte) []byte { return bytes.ToLower(wordBarrierRegex.ReplaceAll( match, []byte(`${1}_${2}`), )) }, ) return converted, err } // struct和db字段互转 var DB *sqlx.DB func init(){ // 使用sqlx包与数据库交互  DB = sqlx.MustConnect(\u0026#34;mysql\u0026#34;, \u0026#34;db connection\u0026#34;) // 支持自定义MapperFunc, 使用strcase包中的ToSnake  DB.MapperFunc(strcase.ToSnake) DB = DB.Unsafe() }   ","description":"","id":19,"section":"posts","tags":["后端","Golang"],"title":"Golang避免使用struct tag","uri":"https://blog.syzh.fun/posts/syzh/golang-reduce-json-db-tag/"},{"content":"js的继承总结 本质都是原型链，设置子类的prototype，应用的时候实例属性定义在实例上，通用方法定义在原型链上，达到较好的复用和扩展效果。 方法一 继承父类的实例 function Father() { this.property = true; // 实例属性 } Father.prototype.getFatherValue = function(){ return this.property; // 通用方法 } function Son(){ this.sonProperty = false; } Son.prototype = new Father();//继承 Son.prototype.getSonProperty = function(){ return this.sonProperty } var instance = new Son(); instance.getFatherValue() 方法二 object.create 此方法是《你不知道的js》所推荐的方法，已经被广泛使用，此方法可以避免 new Father() 有可能会带来的负面作用\nfunction Father() { this.property = true; // 实例属性 } Father.prototype.getFatherValue = function(){ console.log('father') return this.property; // 通用方法 } function Son(){ Father.apply(this,arguments) // 子类借用父类的构造方法 实现继承实例属性 } // 注意是 Father.prototype Son.prototype = Object.create(Father.prototype,{ constructor: { value: Father; // 弥补这种方法的不足 } }) // 或者添加一句 // Son.constructor = Father Son.prototype.getSonProperty = function(){ return this.sonProperty } var instance = new Son(); instance.getFatherValue() 方法三 es6 class 本质还是原型链的语法糖，但是对于面向对象开发友好\nclass Father { constructor(name) { this.name = name; // 增加到实例上 } // 这里声明的普通方法都添加到原型上 drink() { console.log('father drink') } } class Son extends Father { // 关键是extends constructor(name) { // 如果没有constructor 默认使用父类的 // 这里的super指向的是父类 默认里面的this就是子类 super(name); // Animal.call(this) } drink() { // super = Super.prototype 这个super不能单独打印 super.drink(); console.log('son drink') } } let son = new Son(); son.drink() // super 指向有两种可能 在constructor 和 static中指向的是父类 // 在子类的原型方法中指向的是父类原型 // 静态方法 就是通过类来调用的方法 方法四 Object.setPrototypeOf 原理 方法设置一个指定的对象的原型 ( 即, 内部[[Prototype]]属性），mdn 从性能考虑不建议 链接\n// 就是直接修改 __proto__ function Father() { this.property = true; // 实例属性 } Father.prototype.getFatherValue = function(){ console.log(123) return this.property; // 通用方法 } function Son(){ this.sonProperty = false; } Object.setPrototypeOf(Son.prototype,Father.prototype) Son.prototype.getSonProperty = function(){ return this.sonProperty } var instance = new Son(); instance.getFatherValue() ","description":"","id":20,"section":"posts","tags":["前端","JavaScript"],"title":"JavaScript的继承总结","uri":"https://blog.syzh.fun/posts/hxd/js-inheritance/"},{"content":"虽然博客不多, 写博客以来的时间不长, 但是折腾并不少\u0026hellip;记录一下这个博客的折腾历程 Golang时期 最初是想写个博客, 巩固一下Golang知识的, 以及hxd同学刚刚学了react, 也可以练练手. 大部分准备工作也是这段时间做的\n购买域名 最初的域名是在google买的, 要20$一年, 后来偶然发现阿里云有在卖域名, 就是当前这个, 不到200块/10年, 觉得挺合适, 果断就买了\n购买服务器 趁着腾讯云搞活动, 88¥/年买的, 后来发现性能确实不行\u0026hellip;不过88一年也不能要求太高啦\n开发语言的选择 当时学了Golang和Rust, 想着区区一个博客, 用Rust岂不是杀鸡用牛刀了, 加上Golang在服务端开发上的优势, 于是选择了Golang来开发后端. 也为后来用Rust重写买下了伏笔\u0026hellip;\nWeb框架的选择 其实Golang做服务端开发已经够方便了, 也有很多人推荐不使用框架. 基于在reddit里的探索, 选择了一个简单的router: go-chi\nORM的选择 没有选择GORM, XORM等, 感觉有点重量级了. 多方探索, 选择了sqlx\nhttps证书 使用了acme.sh, 免费, 且支持自动更新\nRust时期 大概2019年12月的时候, Rust支持了async/await语法, 于是想动手试一试, 拿博客开刀了\nWeb框架的选择 Rust作为性能著称的语言, 很多框架也都同时支持异步. 比如actix-web, warp, tower-web, tide. 最终选择了相对简单的tide框架(与tide对应, 还有一个异步http client: surf. 二者都是http-rs的作品, 寓意surf the tide)\nMysql Client Rust社区当时现有的Mysql Client, 大多数不支持异步, 支持异步的里面, 又大多数不支持Mysql\u0026hellip;最终选择了sqlx, 支持编译时检查sql语句\n与Golang博客的性能对比 写完后, 用wrk工具对比了下二者的性能, Rust版本的还是比较快. 当然Golang版本使用的是同步的逻辑, 如果使用Goroutine请求数据库, 可能也会很快.\nGohugo时期 服务器还有几个月就要到期了, 一想到又要配置Mysql, Redis, 以及未完成的elasticsearch搜索, 评论功能等, 就有点头大. 虽说用docker可以解决, 但是还有什么比静态网站更省心呢\u0026hellip;\n静态网站生成器的选择 这个没做太多比较, 了解到有Hexo, Gohugo, Rust Zola等等. Gohugo各方面都满足我需求, 就选了这个\nHugo theme的选择 静态网站的话, theme应该是最重要的选择了. 列举了一下自己需要的功能:\n 首页列表简洁 支持明暗配色 支持分类/标签 文章支持显示目录 列表中的文章, 支持配图 最好支持搜索 最好支持手机浏览   比较了一些, 把范围缩小在zzo, even, jane, 最终选择了zzo(zzo还支持相册, 演示, 陈列柜, 出版物等功能, 有兴趣的同学可以研究下)\n评论系统的选择 本着纯静态的思想, 选择了utterances, 基于GitHub issues. 缺点是需要登录GitHub授权, 以及可能需要科学上网\n持续折腾中\u0026hellip; 最后, 希望自己和hxd同学能坚持写这个博客, 积少成多, 加油💪\n","description":"","id":21,"section":"posts","tags":["博客"],"title":"博客折腾记(持续更新)","uri":"https://blog.syzh.fun/posts/syzh/blog-system-change-updating/"},{"content":"随着公司的发展和项目的迭代，很多团队都维护者一个越来越庞大的前端项目群，其中可能有jquery项目，vue项目，react项目，如何更好的分割和整合项目，成为很多工程师的需求。参考后端微服务的概念，前端提出了微前端的方案。\nsingle-spa是其中比较有人气的，本文也是在基于学习这里的内容给出的总结。同时也研究了\n这里 的代码\n微前端的优势：\n 在同一页面上使用多个前端框架 而不用刷新页面 (React, AngularJS, Angular, Ember, 你正在使用的框架) 独立部署每一个单页面应用 新功能使用新框架，旧的单页应用不用重写可以共存 改善初始加载时间，延迟加载代码  在我理解来看，微前端主要满足用一个更好的调度框架，来调度各个不同项目在页面的展示的需求。\n例如 /#reactApp 就加载react项目，\n/#vueApp 就加载vue项目，路由切换可以卸载当前项目，切换新项目。说到底每个项目就是一个通过打包之后的bundle.js,也就是说路由切换可以加载不同的js进来，每个js都维护一个单页应用。\n在single-spa 中，每一个项目都是一个application,以下简称app,为了single-spa可以很好的调度各项目的加载，卸载流程，首先每个项目需要包装统一接口，\n1 2 3 4 5  const app1 = { bootstrap: () =\u0026gt; Promise.resolve(), //bootstrap function  mount: () =\u0026gt; Promise.resolve(), //mount function  unmount: () =\u0026gt; Promise.resolve(), //unmount function }   每个项目都有 bootstrap，mount,unmout 回调，其中回调返回promise,也可以包含一个数组，其中每一项都是返回promise的函数。promise 支持后面强大的链式调用，可以让single-spa将app 像管道一样筛选，加载，卸载。app回调函数会在single-spa合适的调度时机被调用。\n其中例如mount 回调中，不同的app可以分别执行自己的渲染,single-spa会传入参数，也就是说不同的app都需要调整自己的入口文件，满足app的回调才能嵌入这个更加灵活的整体\n1 2 3 4 5 6 7 8 9 10  export function mount(props) { return Promise .resolve() .then(() =\u0026gt; { // Do framework UI rendering here  // 这里可以分别调用react/vue 的渲染  console.log(\u0026#39;mounted!\u0026#39;) }); }   为了更加方便得控制app,分类app,手写微前端框架 提出了app的11个状态，每个状态对应一个app 在加载/启动/挂载/卸载 过程中的某个阶段，任何一个阶段出错了，状态都成为出错状态，不可逆。\n为了确保single-spa 处理路由在任何app之前，采用拦截window.addEventlistener 的方法，在拦截的方法里将hashchange|popstate 这连个事件存储起来，先不执行，默认只执行single-spa添加的hashchange|popstate，等到single-spa 控制流程结束，再依次触发（此时就是react-router、vue-router等绑定的事件）\n整个流程的核心在于single-spa 的核心流程，默认首先加载被注册的app，然后判断是否需要挂载/卸载app,如果浏览器或者手动触发了需要更改app,再依次执行卸载不需要的，挂载需要的app流程。此流程核心代码位于/my-single-spa/src/navigation/invoke.js\n","description":"","id":22,"section":"posts","tags":["前端"],"title":"微前端学习总结","uri":"https://blog.syzh.fun/posts/hxd/micro-front-end/"},{"content":"mac app   快捷启动: alfred\n alfred基本算是mac必备app了, 主要用到的功能如下  快捷启动 文件搜索 snippets短语扩展 计算器 字典 密码管理1password   workflows  颜色色值相关转换: Colors v2.0.2 时间格式相关转换: Datetime Format Converter 编解码: Encode / Decode v1.8.0 快捷打开项目: JetBrains - Open project 命令用法速查: tldr uuid生成器: uuid generator      数据库连接: sequel pro\n 虽然已经基本停止开发了, 也尝试过其他诸如datagrip, 不过不习惯, 又换回来了    备份: mac自带的time machine\n  gif录屏: licecap\n  pdf阅读器: skim/pdfelement, 后者备用\n  任务管理: omniFocus\n  视频播放器: iina\n  键盘自定义映射: karabiner\n 把长按enter映射为ctrl, 点击capslock映射为esc, 长按capslock映射为ctrl等等 更多复杂映射, 比如emacs专用映射等等, 可以在这里找到    系统指标监视器: istat menus\n 在菜单栏显示上下行流量, cpu温度, cpu使用率等等    终端: iterm\n  密码管理: 1password\n  清理键盘辅助工具: KeyboardCleanTool\n  文本编辑器: sublime/vscode\n  工作休息提醒: stretchly\n  浏览图片: xnviewMP\n  文件同步: dropbox\n  抓包: charles\n  菜单栏图标管理: bartender\n  自动切换壁纸: irvue\n  思维导图: scapple\n  听歌: spotify + telegram\n telegram的vk music bot机器人可以搜索并下载各种歌曲, 而且自带的音乐播放功能还不错\u0026hellip;    markdown编辑器: typora + ipic\n typora可以支持很多$\\LaTeX$公式符号等等 ipic可以帮助typora自动上传图片    命令行工具  包管理器: homebrew http客户端: httpie git diff增强: diff-so-fancy 文件查找(替代find): fd shell: fish 命令历史查找: fzf 文件内容搜索(替代grep): ripgrep  各种ide/编辑器配色方案: dracula 在线latex编辑器: overleaf ","description":"","id":23,"section":"posts","tags":["MacOS"],"title":"记录一下mac里装的应用","uri":"https://blog.syzh.fun/posts/syzh/my-mac-app/"},{"content":"小站的评论系统使用了utterances, 基于GitHub issues, 因此可能需要科学上网支持\n不方便的同学, 欢迎通过每篇博文底部的作者邮箱或Github账号与我们联系\n","description":"Hugo, the world’s fastest framework for building websites","id":28,"section":"","tags":null,"title":"About","uri":"https://blog.syzh.fun/about/"}]