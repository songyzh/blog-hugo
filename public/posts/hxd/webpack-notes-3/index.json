[{"content":"本文对于webpack 编译出的内容做分析总结。\n普通文件引入的打包 1 2  // src/test.js module.exports = \u0026#39;test\u0026#39;   1 2 3  // src/index.js let test = require(\u0026#39;./test\u0026#39;); console.log(test)   打包后的main.js(摘取部分)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36  // 打包入口 ./src/index.js (function (modules) { var installedModules = {}; function __webpack_require__(moduleId) { // 缓存作用，如果已经引入过了，使用引入过的结果  if (installedModules[moduleId]) { return installedModules[moduleId].exports; } var module = installedModules[moduleId] = { i: moduleId, l: false, exports: {} }; modules[moduleId].call(module.exports, module, module.exports, __webpack_require__); module.l = true; return module.exports; } return __webpack_require__(__webpack_require__.s = \u0026#34;./src/index.js\u0026#34;); }) ({ // 包装成一个模块对象 绝对路径对应这个模块  \u0026#34;./src/index.js\u0026#34;: (function (module, exports, __webpack_require__) { // 将代码中的require -\u0026gt;__webpack_require__ t console.log(test) }), \u0026#34;./src/test.js\u0026#34;: (function (module, exports) { module.exports = \u0026#39;test\u0026#39; }) });   在我理解看来，在打包的过程中，每个模块被封装成了一个函数，此时模块代码并没有被执行，而是被放在了打包文件自执行函数的参数modules 中，从这个自执行函数的末尾\n1  return __webpack_require__(__webpack_require__.s = \u0026#34;./src/index.js\u0026#34;);   开始，根据入口文件引用的文件逐一运行，原文件中的require 被替代成__webpack_require__，也就是说，webpack打包的文件都没有使用node/es6的引用方法，而是自己实现的__webpack_require__方法。\n从__webpack_require__('./src/index.js\u0026rsquo;)开始，拿到参数modules中被包装的index.js 的内容，遇到__webpack_require__('./src/test.js\u0026rsquo;) 时，运行参数modules中./src/test.js 对应的封装方法，每运行完一个模块，就会为其生成一个module对象添加到installedModules，{ i: moduleId, l: false, exports:{}},保存其路径i，导出的内容exports，标记是否已经加载过l,installedModules 可以起到缓存的作用，如果已经加载过的模块可以直接从installedModules里拿到。\n不同引入方法的打包 众所周知，目前比较流行的模块加载方式是nodejs的module.exports/require 以及es6的 import/export,在webpack中这两种打包方式都支持，也就是上文中的__webpack_require__ 两种都支持，尝试通过es6 将上例中的test.js 修改成\n1 2  // src/test.js export const test = \u0026#39;test\u0026#39;   打包后的main.js(摘取部分)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61  (function(modules) { // webpackBootstrap  // The module cache  var installedModules = {}; // The require function  function __webpack_require__(moduleId) { if(installedModules[moduleId]) { return installedModules[moduleId].exports; } var module = installedModules[moduleId] = { i: moduleId, l: false, exports: {} }; modules[moduleId].call(module.exports, module, module.exports, __webpack_require__); module.l = true; return module.exports; } __webpack_require__.m = modules; __webpack_require__.c = installedModules; __webpack_require__.d = function(exports, name, getter) { if(!__webpack_require__.o(exports, name)) { Object.defineProperty(exports, name, { enumerable: true, get: getter }); } }; __webpack_require__.r = function(exports) { if(typeof Symbol !== \u0026#39;undefined\u0026#39; \u0026amp;\u0026amp; Symbol.toStringTag) { Object.defineProperty(exports, Symbol.toStringTag, { value: \u0026#39;Module\u0026#39; }); } Object.defineProperty(exports, \u0026#39;__esModule\u0026#39;, { value: true }); }; __webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); }; return __webpack_require__(__webpack_require__.s = \u0026#34;./src/index.js\u0026#34;); }) ({ \u0026#34;./src/index.js\u0026#34;: (function(module, exports, __webpack_require__) { let test = __webpack_require__(\u0026#34;./src/test.js\u0026#34;); console.log(test) }), \u0026#34;./src/test.js\u0026#34;: (function(module, __webpack_exports__, __webpack_require__) { __webpack_require__.r(__webpack_exports__); __webpack_require__.d(__webpack_exports__, \u0026#34;test\u0026#34;, function() { return test; }); const test = \u0026#39;test\u0026#39; }) });   可以看出，与上例中最大的区别是包装test.js 发生了变化，去除了export 关键字，并且添加了\n__webpack_require__.r(__webpack_exports__); __webpack_require__.d(__webpack_exports__, \u0026quot;test\u0026quot;, function() { return test; }); 查看__webpack_require__.r方法，发现是向模块运行结果exports中添加标记，标记当前模块__esModule 为true,如果是支持\nSymbol的浏览器，也添加一个Symbol值为Module，这种标记是为了后续有需要的地方可以识别此模块的导出方式，__webpack_require__.d 方法则是为当前导出的exports 对象上添加一个值为\u0026rsquo;test\u0026rsquo;的test 属性，如此一来，test.js 也有了module.exports = {test: \u0026lsquo;test\u0026rsquo;}的效果。\n同理，其他导出/导入组合，webpack 都会对包装函数做不同的处理，以便能统一达到效果。\n","description":"","id":2,"section":"posts","tags":["前端","webpack"],"title":"webpack 学习总结 三","uri":"https://blog.syzh.fun/posts/hxd/webpack-notes-3/"},{"content":"上一篇总结了webpack中使用的一些库，这一篇来总结下webpack整体流程,主要根据代码流程来总结。\n","description":"","id":3,"section":"posts","tags":["前端","webpack"],"title":"webpack 学习总结 二","uri":"https://blog.syzh.fun/posts/hxd/webpack-notes-2/"},{"content":"webpack 是当前前端项目打包当中非常流行的打包框架，结合丰富的流程钩子函数、插件系统以及nodejs部分功能 给开发者提供了方便配置，易于扩展的打包工具，在学习webpack源码流程(4.43.0)的这段时间收获很多，在此做一些总结。\n本文首先总结下，在webpack中用到的诸多工具项目，他们在实现整体流程中起到了很大的作用。\n一 Tapable Tapable是webpack流程的基础，整个编译过程，各个模块的方法调用都是基于Tapable的事件注册和触发。相对于nodejs 的EventEmitter，Tapable提供了事件触发的更多形式，同步触发，异步并行触发，异步串行触发等等，可以满足不同需求。\n在webapck中，最主要的Compiler和Compilation类都继承了\nTapable，从而可以生成自己的一系列钩子函数，这些钩子函数在流程控制中起到承上启下的作用，也为开发者自定义功能提供了灵活的接口。\n官网中的例子：\nconst { SyncHook, AsyncParallelHook, } = require(\u0026quot;tapable\u0026quot;); class Car { constructor() { this.hooks = { accelerate: new SyncHook([\u0026quot;newSpeed\u0026quot;]), brake: new SyncHook(), calculateRoutes: new AsyncParallelHook([\u0026quot;source\u0026quot;, \u0026quot;target\u0026quot;, \u0026quot;routesList\u0026quot;]) }; } /* ... */ } const myCar = new Car(); // 相当于给brake钩子添加一个事件（此时并不会执行，可以添加多个） myCar.hooks.brake.tap(\u0026quot;WarningLampPlugin\u0026quot;, () =\u0026gt; warningLamp.on()); // 触发钩子函数,可以在需要的时机来触发，webpack中正是利用这一点来统一给各流程添加逻辑 myCar.hooks.brake.call() 二 neo-async neo-async 其中的forEach 方法可以方便的进行异步循环，循环结束后执行回调,在webpack中处理模块依赖时需要用到该方法来确保在模块的所有依赖处理完成之后进行下一步。\n// array var order = []; var array = [1, 3, 2]; var iterator = function(num, done) { setTimeout(function() { order.push(num); done(); }, num * 10); }; async.each(array, iterator, function(err, res) { console.log(res); // undefined console.log(order); // [1, 2, 3] }); 三 Semaphore Semaphore\n是一个控制并发数量的工具，可以设置最大并发量，在任务结束时释放容量，每次take 一个任务时都会查看是否到达容量极限，如果到达会存储任务到队列中，等待容量被释放时再从队列中取出任务执行\n// 2 clients at a time var sem = require('semaphore')(2); var server = require('http').createServer(req, res) { res.write(\u0026quot;Then good day, madam!\u0026quot;); sem.take(function() { res.end(\u0026quot;We hope to see you soon for tea.\u0026quot;); sem.leave(); }); }); webpack中工厂函数生成多个模块 以及编译模块时都采用了\nSemaphore 来控制并发\n四 利用Object.defineProperty 重写get函数来添加一些内容获取的逻辑 let test = {arr: [1,2,2,3,4,5] } let res = {} Object.defineProperty(res, 'arr', { get() { // 这里可以自由添加自己需要的逻辑 return test.arr.filter(item=\u0026gt;item\u0026gt;1); } }); console.log(res.arr)// [2, 2, 3, 4, 5] webpack 中LoaderRunner.js 中就采用了这一技巧对loader进行信息采集\n","description":"","id":4,"section":"posts","tags":["前端","webpack"],"title":"webpack 学习总结 一","uri":"https://blog.syzh.fun/posts/hxd/webpack-notes-1/"},{"content":"  程序执行到defer语句的时候, 被defer的函数的实参会在此时被求值\n  1 2 3 4 5 6 7 8 9 10  func a() { i := 0 // 被defer的函数实参会在此时被求值, 这里为0  defer fmt.Println(i) // i自增, 但不会影响defer的函数  i++ return } //===========输出=========== 0       被defer的函数调用, 执行顺序是\u0026quot;后进先出\u0026rdquo;\n  defer的函数调用会被压入一个栈中。当外层函数返回时，被推迟的函数会按照后进先出的顺序调用。\n  如果函数的返回值是命名的, defer语句中的函数可以读取或修改该值\n  1 2 3 4 5 6 7 8 9  // 修改命名的返回值 func c() (i int) { // 在defer语句中自增  defer func() { i++ }() // 这里i被设为1  return 1 } //=============输出============ 2     1 2 3 4 5 6 7 8  // 返回值是匿名的, 无法被defer修改 func c() int { i := 1 defer func() { i++ }() return i } //=============输出============ 1       实参估值和修改返回变量的例子\n  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  func test() (x int) { // defer语句的实参会被立刻估值, 因此实参x==0  defer func(n int) { // 实参x估值为0, 因此形参n==0  fmt.Printf(\u0026#34;in defer x as parameter: x = %d\\n\u0026#34;, n) // 这里的x是外面的x, 因此为9  fmt.Printf(\u0026#34;in defer x after return: x = %d\\n\u0026#34;, x) }(x) x = 7 // x==9  return 9 } // =============执行结果============== in defer x as parameter: x = 0 in defer x after return: x = 9       最好在获取资源之后, 立刻调用defer\n  defer在其所在的函数的末尾执行, 因此在for循环中使用时要注意\n  1 2 3 4 5 6 7 8 9 10  // 有问题的写法 for _, filename := range filenames { f, err := os.Open(filename) if err != nil { return err } // 释放资源的操作直到所在函数末尾才执行, 如果文件很多, 可能导致文件描述符用尽  defer f.Close() // 处理文件 }     1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  // 改进写法 for _, filename := range filenames { if err := doFile(filename); err != nil { return err } } // 抽取处理单个文件的逻辑, 此函数返回时即可关闭文件 func doFile(filename string) error { f, err := os.Open(filename) if err != nil { return err } defer f.Close() // 处理文件 }       ","description":"","id":5,"section":"posts","tags":["后端","Golang"],"title":"Golang defer语句用法小结","uri":"https://blog.syzh.fun/posts/syzh/golang-defer/"},{"content":"  sync包提供传统的内存访问的同步机制\n  WaitGroup\n  等待若干goroutine执行完毕\n  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33  // 注意: 如果wg是在闭包环境中使用, 由于闭包中捕获的是变量本身, 因此直接使用wg变量即可. 但如果是下面代码这样, 作为函数的参数调用, 则需要传引用来保证使用的是同一个wg  // 传入公用的wg对象 hello := func(wg *sync.WaitGroup, id int) { // 执行完成后, 内部值-1  defer wg.Done() fmt.Printf(\u0026#34;Hello from %v!\\n\u0026#34;, id) } // 定义goroutine数量 const numGreeters = 5 // 初始化waitgroup var wg sync.WaitGroup // 一次性增加内部值, 也可以在for语句中逐个增加 wg.Add(numGreeters) for i := 0; i \u0026lt; numGreeters; i++ { // wg.Add(1) 如果使用逐个增加的方式  go hello(\u0026amp;wg, i+1) } // 阻塞, 直到内部值变为0 wg.Wait() //===========输出=============== // 顺序不确定 Hello from 1! Hello from 5! Hello from 2! Hello from 3! Hello from 4!       Mutex and RWMutex\n  保护关键区域(guard critical sections)\n  Mutex\n  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  var count int var lock sync.Mutex // 下面两个函数都是线程安全的 increment := func() { lock.Lock() // 使用defer, 确保锁被释放  defer lock.Unlock() count++ fmt.Printf(\u0026#34;Incrementing: %d\\n\u0026#34;, count) } decrement := func() { lock.Lock() defer lock.Unlock() count-- fmt.Printf(\u0026#34;Decrementing: %d\\n\u0026#34;, count) }       RWMutex\n  可以同时有任意多个读锁, 或一个写锁\n  读锁是共享的, 写锁是排他的\n  1 2 3 4 5 6 7 8 9 10 11 12 13 14  var mu sync.RWMutex var balance int func Balance() int { mu.RLock() // readers/shared lock  defer mu.RUnlock() return balance } func Deposit(amount int) { mu.Lock() // // writer/exclusive lock  defer mu.Unlock() balance += amount }         Cond\n  在某个点等待某事件(event)的发生, 在此之前保持阻塞/挂起状态, 使其他goroutine可以执行\n  用于notify的方法\n Signal: 通知等待最久的goroutine, 这个功能也可以用channel实现  runtime维护了一个FIFO保存等待通知的goroutine, 因此会通知等待最久的goroutine   Broadcast: 通知所有goroutine, 这个功能用channel不好实现    性能比使用channel实现好很多\n  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38  // 假设我们有一个固定len为2的queue, 我们想加入10个元素进去. 我们希望queue一有多余的空间, 就能通知我们, 让我们插入新的元素  // 创建一个cond, 需要传入一个sync.Locker来保护关键区域 c := sync.NewCond(\u0026amp;sync.Mutex{}) // 初始化queue queue := make([]interface{}, 0, 10) // dequeue函数 removeFromQueue := func(delay time.Duration) { // sleep delay的时间  time.Sleep(delay) // 使用lock保护关键区域  c.L.Lock() // dequeue  queue = queue[1:] fmt.Println(\u0026#34;Removed from queue\u0026#34;) // unlock, 离开关键区域  c.L.Unlock() // 通知等待最久的goroutine, 也可以用broadcast来通知所有  c.Signal() } for i := 0; i \u0026lt; 10; i++ { // 进入关键区域  c.L.Lock() // 需要使用for循环来检查条件. 因为接到通知并不一定意味着我们在等待的事情已经发生, 所以需要再次检查条件  for len(queue) == 2 { // 在内部会先调用unlock, 然后等待. 接到通知继续执行后, 会调用lock  c.Wait() } fmt.Println(\u0026#34;Adding to queue\u0026#34;) // enqueue  queue = append(queue, struct{}{}) // 启动goroutine, 1s后执行dequeue  go removeFromQueue(1 * time.Second) // 离开关键区域  c.L.Unlock() }       Once\n  每个sync.Once的对象, 只能调用1次Do方法, 之后的对Do的调用无效.\n  1 2 3 4 5 6 7 8 9 10 11 12  var count int increment := func() { count++ } decrement := func() { count-- } var once sync.Once // 第一次调用Do方法, 有效 once.Do(increment) // 此次调用Do方法无效 once.Do(decrement) fmt.Printf(\u0026#34;Count: %d\\n\u0026#34;, count) // count为1, once对象只能执行一次DO方法       Pool\n  创建一个对象池, 其中的对象可以复用(比如数据库连接), 且是线程安全的\n  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  myPool := \u0026amp;sync.Pool{ // 生成新对象  New: func() interface{} { fmt.Println(\u0026#34;Creating new instance.\u0026#34;) return struct{}{} }, } // pool是空的, 因此会创建新对象 myPool.Get() // 上面创建的对象没有被放回, 因此现在pool中还是空的 // 由于pool是空的, 因此会创建新对象 instance := myPool.Get() // 放回对象, 经常配合defer使用 myPool.Put(instance) // 由于pool中有对象, 因此不会创建新对象 myPool.Get() //============输出============ Creating new instance. Creating new instance.       ","description":"","id":6,"section":"posts","tags":["后端","Golang","GoSync"],"title":"Golang sync包用法小结","uri":"https://blog.syzh.fun/posts/syzh/golang-sync/"},{"content":"提供了Golang交替打印的几个思路: 使用Goroutine, sync包中的WaitGroup和Cond\n  使用unbuffered channel实现\n  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36  func PrintABUnbufferedChannel() { // 使用2个channel实现交替运行  c1 := make(chan struct{}) c2 := make(chan struct{}) // 打印aaa的函数, 对2个channel执行send操作  PrintA := func() { for { c1 \u0026lt;- struct{}{} fmt.Println(\u0026#34;aaa\u0026#34;) time.Sleep(1 * time.Second) c2 \u0026lt;- struct{}{} } } // 打印bbb的函数, 对2个channel执行receive操作  PrintB := func() { for { \u0026lt;-c2 fmt.Println(\u0026#34;bbb\u0026#34;) time.Sleep(1 * time.Second) \u0026lt;-c1 } } // 先打印aaa  go func() { \u0026lt;-c1 }() go PrintA() go PrintB() time.Sleep(1 * time.Hour) }       使用sync.Cond配合sync.WaitGroup实现\n  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54  func PrintABCond() { // 使用2个cond实现交替运行  c1 := sync.NewCond(\u0026amp;sync.Mutex{}) c2 := sync.NewCond(\u0026amp;sync.Mutex{}) // 使用waitgroup协调顺序, 确保printA, printB先启动, 再发送第一个signal  var wg sync.WaitGroup // 打印aaa的函数, 等待c1, 通知c2  printA := func() { // 确保printA启动早于第一个signal  wg.Done() for { c1.L.Lock() // 等待信号  c1.Wait() fmt.Println(\u0026#34;aaa\u0026#34;) time.Sleep(1 * time.Second) // 发送信号  c2.Signal() c1.L.Unlock() } } // 打印bbb的函数, 等待c2, 通知c1  printB := func() { // 确保printB启动早于第一个signal  wg.Done() for { c2.L.Lock() // 等待信号  c2.Wait() fmt.Println(\u0026#34;bbb\u0026#34;) time.Sleep(1 * time.Second) // 发送信号  c1.Signal() c2.L.Unlock() } } wg.Add(2) // 先打印aaa  go func() { // 等待printA, printB启动后, 再发送第一个signal  wg.Wait() c1.Signal() }() go printA() go printB() time.Sleep(1 * time.Hour) }       使用for-select语句实现, 与方法1类似\n  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  func PrintABForSelect() { c1 := make(chan struct{}) c2 := make(chan struct{}) printAB := func() { for { select { case \u0026lt;-c1: fmt.Println(\u0026#34;aaa\u0026#34;) time.Sleep(1 * time.Second) c2 \u0026lt;- struct{}{} case \u0026lt;-c2: fmt.Println(\u0026#34;bbb\u0026#34;) time.Sleep(1 * time.Second) c1 \u0026lt;- struct{}{} } } } go func() { c1 \u0026lt;- struct{}{} }() go printAB() go printAB() time.Sleep(1 * time.Hour) }       ","description":"","id":7,"section":"posts","tags":["后端","Golang","Goroutine","GoChannel","GoSync"],"title":"Golang交替打印的几种实现方式","uri":"https://blog.syzh.fun/posts/syzh/golang-goroutine-coordinate/"},{"content":"三色标记-清除算法(tricolor mark-and-sweep algorithm)\n 把heap中的对象, 用黑色, 灰色, 白色进行标记  黑色对象: 已经以其为root执行过可达性分析的对象 灰色对象: 需要但还未以其为root执行过可达性分析的对象 白色对象: 从gc root无法被触达的对象, 可能被垃圾回收   垃圾回收过程  垃圾回收开始时, 所有对象都是白色. 所有root对象被标记为灰色. root对象指程序可以直接访问的对象, 包含全局变量, 位于栈上的数据. 垃圾回收器选择一个灰色对象, 把它标记为黑色, 寻找其可以触达的白色对象, 并把它们标记为灰色. 直到把所有灰色对象都处理过一遍 此时的白色对象说明无法被触达, 因此可以被垃圾回收 如果在垃圾回收过程中, 某个灰色对象变得不可触达了, 则它会在下次垃圾回收时被清理   标记过程中, 执行中的应用程序被称为mutator, mutator有一个函数write barrier. 当heap中的某个对象被修改了, 说明该对象可被触达, 则write barrier会把此对象标记为灰色 当某channel无法被触达时, 即使其未被close, 也会被垃圾回收, 清理其占用的资源 手动触发GC: runtime.GC(), 此操作会阻塞调用者, 并可能阻塞整个程序 mark阶段, 标记对象; 没有灰色对象后, 开始sweep阶段 go的垃圾回收是与其他goroutine并发执行的  ","description":"","id":8,"section":"posts","tags":["后端","Golang","垃圾回收"],"title":"Golang垃圾回收-三色算法概览","uri":"https://blog.syzh.fun/posts/syzh/golang-garbage-collector-tricolor/"},{"content":"  问题表现\n  使用下标获取字符串的字符时, 可能得到奇怪的字符\n  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  func main() { s := \u0026#34;hello\u0026#34; fmt.Printf(\u0026#34;%c\\n\u0026#34;, s[1]) s = \u0026#34;你好\u0026#34; fmt.Printf(\u0026#34;%c\\n\u0026#34;, s[1]) } //============输出===========  e ½       问题原因\n golang是以utf8格式保存字符串的, 字符串的下标操作, 访问的是字节, 而不是字符. len函数输出的也是字节数, 如len(\u0026quot;hello\u0026quot;)==5, len(\u0026quot;你好\u0026quot;)==6    避免方式\n  把字符串转化为[]rune/[]int32, 或者使用range遍历\n  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  func main() { s := \u0026#34;你好\u0026#34; // 强转为[]rune  fmt.Printf(\u0026#34;%c\\n\u0026#34;, []rune(s)[1]) fmt.Println() // 使用range遍历  for _, c := range s { fmt.Printf(\u0026#34;%c\\n\u0026#34;, c) } } //===============输出=================  好 你 好       ","description":"","id":9,"section":"posts","tags":["后端","Golang","踩坑"],"title":"Golang踩坑总结-使用下标获取字符串的字符","uri":"https://blog.syzh.fun/posts/syzh/golang-pitfall-string-subscript/"},{"content":"  问题表现\n  goroutine中捕获的循环变量, 都为循环最后的值\n  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  func main() { for i, v := range []string{\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;, \u0026#34;d\u0026#34;, \u0026#34;e\u0026#34;} { // goroutine中捕获循环变量  go func() { fmt.Printf(\u0026#34;index: %v, value: %v\\n\u0026#34;, i, v) }() } // 此处应该使用workgroup实现, 为了简单使用了sleep  time.Sleep(1 * time.Second) } //================输出==============  index: 4, value: e index: 4, value: e index: 4, value: e index: 4, value: e index: 4, value: e       问题原因\n goroutine中捕获的不是\u0026quot;值\u0026rdquo;, 而是\u0026quot;有地址的变量\u0026rdquo;. for循环可能会先结束, 之后各个goroutine才开始执行. 因此得到的是变量的最终值    避免方式\n  在goroutine启动的函数中, 把变量作为参数捕获\n  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  func main() { for i, v := range []string{\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;, \u0026#34;d\u0026#34;, \u0026#34;e\u0026#34;} { // 把循环变量作为参数传入  go func(i int, v string) { // i, v是函数内部的局部变量  fmt.Printf(\u0026#34;index: %v, value: %v\\n\u0026#34;, i, v) }(i, v) } time.Sleep(1 * time.Second) } //================输出==============  index: 0, value: a index: 1, value: b index: 4, value: e index: 3, value: d index: 2, value: c       ","description":"","id":10,"section":"posts","tags":["后端","Golang","踩坑","Goroutine"],"title":"Golang踩坑总结-循环中使用Goroutine中捕获参数","uri":"https://blog.syzh.fun/posts/syzh/golang-pitfall-for-goroutine/"},{"content":"  问题表现\n  闭包中捕获的循环变量, 都为循环最后的值\n  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  func main() { // 保存函数闭包  var s []func() for i, v := range []string{\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;, \u0026#34;d\u0026#34;, \u0026#34;e\u0026#34;} { s = append(s, func() { // 捕获i, v, 保存在闭包中  fmt.Printf(\u0026#34;index: %v, value: %v\\n\u0026#34;, i, v) }) } for _, f := range s { f() } } // ====================输出===========================  index: 4, value: e index: 4, value: e index: 4, value: e index: 4, value: e index: 4, value: e       问题原因\n 闭包中捕获的不是\u0026quot;值\u0026rdquo;, 而是\u0026quot;有地址的变量\u0026rdquo;. 最终执行时, 根据变量寻址, 得到的是变量最后的值    避免方式\n  在循环中, 重新声明要捕获的变量. 由于是单个循环的局部变量, 在其作用域结束前, 会进行evaluate\n  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  func main() { // 保存函数闭包  var s []func() for i, v := range []string{\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;, \u0026#34;d\u0026#34;, \u0026#34;e\u0026#34;} { // 重新声明要捕获的变量  i, v := i, v s = append(s, func() { // 捕获i, v, 保存在闭包中  fmt.Printf(\u0026#34;index: %v, value: %v\\n\u0026#34;, i, v) }) } for _, f := range s { f() } } // ====================输出===========================  index: 0, value: a index: 1, value: b index: 2, value: c index: 3, value: d index: 4, value: e       ","description":"","id":11,"section":"posts","tags":["后端","Golang","踩坑","闭包"],"title":"Golang踩坑总结-循环中使用闭包捕获参数","uri":"https://blog.syzh.fun/posts/syzh/golang-pitfall-for-closure/"},{"content":"  问题表现\n  具体类型的nil值, 赋值给接口值变量后, 被判定不为nil\n  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  func main() { // *bytes.Buffer, 零值为nil  var b *bytes.Buffer if b == nil { fmt.Println(\u0026#34;外面的b等于nil\u0026#34;) } else { fmt.Println(\u0026#34;外面的b不等于nil\u0026#34;) } f := func(b io.Writer) { if b == nil { fmt.Println(\u0026#34;里面的b等于nil\u0026#34;) } else { fmt.Println(\u0026#34;里面的b不等于nil\u0026#34;) } } // 把b传入函数  f(b) } //===========输出===============  外面的b等于nil 里面的b不等于nil       问题原因\n golang中的接口值, 除了有自己的类型type外, 还有动态类型(dynamic type)和动态值(dynamic value). 接口值如果要被判断为nil, 需要动态类型和动态值都为nil. 可以通过fmt的\u0026rdquo;%T\u0026rdquo;, \u0026ldquo;%v\u0026quot;观察动态类型和动态值    打印动态类型和动态值\n  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38  func main() { var b *bytes.Buffer fmt.Printf(\u0026#34;外面的b类型为%T\\n\u0026#34;, b) fmt.Printf(\u0026#34;外面的b值为%v\\n\u0026#34;, b) if b == nil { fmt.Println(\u0026#34;外面的b等于nil\u0026#34;) } else { fmt.Println(\u0026#34;外面的b不等于nil\u0026#34;) } fmt.Println(\u0026#34;\u0026#34;) f := func(b io.Writer) { fmt.Printf(\u0026#34;里面的b类型为%T\\n\u0026#34;, b) fmt.Printf(\u0026#34;里面的b值为%v\\n\u0026#34;, b) if b == nil { fmt.Println(\u0026#34;里面的b等于nil\u0026#34;) } else { fmt.Println(\u0026#34;里面的b不等于nil\u0026#34;) } } f(b) } //==============输出=================  外面的b类型为*bytes.Buffer 外面的b值为\u0026lt;nil\u0026gt; 外面的b等于nil 里面的b类型为*bytes.Buffer 里面的b值为\u0026lt;nil\u0026gt; 里面的b不等于nil       ","description":"","id":12,"section":"posts","tags":["后端","Golang","踩坑"],"title":"Golang踩坑总结-接口值是否等于nil","uri":"https://blog.syzh.fun/posts/syzh/golang-pitfall-interface-value-nil/"},{"content":"最近在用Golang搭建博客后端时, 遇到一个问题: 数据在从mysql到接口输出的json转化中, 需要做字段映射. 常规的方法是写db tag和json tag, 自动进行转换. 这种方式有点麻烦, 尤其struct和字段多起来的时候. 我的场景是mysql字段为snake_case, struct为CamelCase, json字段为snake_case, 就想着用代码来完成转换\n代码示例如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46  // 博客文章struct type Post struct { Content string Cover string CreatedAt time.Time FamilyID int ID int Slug string Status int Title string UpdatedAt time.Time } // struct和json互转 var keyMatchRegex = regexp.MustCompile(`\u0026#34;\\w+\u0026#34;:`) var wordBarrierRegex = regexp.MustCompile(`([a-z])([A-Z])`) // 重写Response类型的MarshalJSON方法 func (resp Response) MarshalJSON() ([]byte, error) { // 创建此类型, 防止递归  type Response_ Response marshalled, err := json.Marshal(Response_(resp)) // 正则替换  converted := keyMatchRegex.ReplaceAllFunc( marshalled, func(match []byte) []byte { return bytes.ToLower(wordBarrierRegex.ReplaceAll( match, []byte(`${1}_${2}`), )) }, ) return converted, err } // struct和db字段互转 var DB *sqlx.DB func init(){ // 使用sqlx包与数据库交互  DB = sqlx.MustConnect(\u0026#34;mysql\u0026#34;, \u0026#34;db connection\u0026#34;) // 支持自定义MapperFunc, 使用strcase包中的ToSnake  DB.MapperFunc(strcase.ToSnake) DB = DB.Unsafe() }   ","description":"","id":13,"section":"posts","tags":["后端","Golang"],"title":"Golang避免使用struct tag","uri":"https://blog.syzh.fun/posts/syzh/golang-reduce-json-db-tag/"},{"content":"js的继承总结 本质都是原型链，设置子类的prototype，应用的时候实例属性定义在实例上，通用方法定义在原型链上，达到较好的复用和扩展效果。 方法一 继承父类的实例 function Father() { this.property = true; // 实例属性 } Father.prototype.getFatherValue = function(){ return this.property; // 通用方法 } function Son(){ this.sonProperty = false; } Son.prototype = new Father();//继承 Son.prototype.getSonProperty = function(){ return this.sonProperty } var instance = new Son(); instance.getFatherValue() 方法二 object.create 此方法是《你不知道的js》所推荐的方法，已经被广泛使用，此方法可以避免 new Father() 有可能会带来的负面作用\nfunction Father() { this.property = true; // 实例属性 } Father.prototype.getFatherValue = function(){ console.log('father') return this.property; // 通用方法 } function Son(){ Father.apply(this,arguments) // 子类借用父类的构造方法 实现继承实例属性 } // 注意是 Father.prototype Son.prototype = Object.create(Father.prototype,{ constructor: { value: Father; // 弥补这种方法的不足 } }) // 或者添加一句 // Son.constructor = Father Son.prototype.getSonProperty = function(){ return this.sonProperty } var instance = new Son(); instance.getFatherValue() 方法三 es6 class 本质还是原型链的语法糖，但是对于面向对象开发友好\nclass Father { constructor(name) { this.name = name; // 增加到实例上 } // 这里声明的普通方法都添加到原型上 drink() { console.log('father drink') } } class Son extends Father { // 关键是extends constructor(name) { // 如果没有constructor 默认使用父类的 // 这里的super指向的是父类 默认里面的this就是子类 super(name); // Animal.call(this) } drink() { // super = Super.prototype 这个super不能单独打印 super.drink(); console.log('son drink') } } let son = new Son(); son.drink() // super 指向有两种可能 在constructor 和 static中指向的是父类 // 在子类的原型方法中指向的是父类原型 // 静态方法 就是通过类来调用的方法 方法四 Object.setPrototypeOf 原理 方法设置一个指定的对象的原型 ( 即, 内部[[Prototype]]属性），mdn 从性能考虑不建议 链接\n// 就是直接修改 __proto__ function Father() { this.property = true; // 实例属性 } Father.prototype.getFatherValue = function(){ console.log(123) return this.property; // 通用方法 } function Son(){ this.sonProperty = false; } Object.setPrototypeOf(Son.prototype,Father.prototype) Son.prototype.getSonProperty = function(){ return this.sonProperty } var instance = new Son(); instance.getFatherValue() ","description":"","id":14,"section":"posts","tags":["前端","JavaScript"],"title":"JavaScript的继承总结","uri":"https://blog.syzh.fun/posts/hxd/js-inheritance/"},{"content":"虽然博客不多, 写博客以来的时间不长, 但是折腾并不少\u0026hellip;记录一下这个博客的折腾历程 Golang时期 最初是想写个博客, 巩固一下Golang知识的, 以及hxd同学刚刚学了react, 也可以练练手. 大部分准备工作也是这段时间做的\n购买域名 最初的域名是在google买的, 要20$一年, 后来偶然发现阿里云有在卖域名, 就是当前这个, 不到200块/10年, 觉得挺合适, 果断就买了\n购买服务器 趁着腾讯云搞活动, 88¥/年买的, 后来发现性能确实不行\u0026hellip;不过88一年也不能要求太高啦\n开发语言的选择 当时学了Golang和Rust, 想着区区一个博客, 用Rust岂不是杀鸡用牛刀了, 加上Golang在服务端开发上的优势, 于是选择了Golang来开发后端. 也为后来用Rust重写买下了伏笔\u0026hellip;\nWeb框架的选择 其实Golang做服务端开发已经够方便了, 也有很多人推荐不使用框架. 基于在reddit里的探索, 选择了一个简单的router: go-chi\nORM的选择 没有选择GORM, XORM等, 感觉有点重量级了. 多方探索, 选择了sqlx\nhttps证书 使用了acme.sh, 免费, 且支持自动更新\nRust时期 大概2019年12月的时候, Rust支持了async/await语法, 于是想动手试一试, 拿博客开刀了\nWeb框架的选择 Rust作为性能著称的语言, 很多框架也都同时支持异步. 比如actix-web, warp, tower-web, tide. 最终选择了相对简单的tide框架(与tide对应, 还有一个异步http client: surf. 二者都是http-rs的作品, 寓意surf the tide)\nMysql Client Rust社区当时现有的Mysql Client, 大多数不支持异步, 支持异步的里面, 又大多数不支持Mysql\u0026hellip;最终选择了sqlx, 支持编译时检查sql语句\n与Golang博客的性能对比 写完后, 用wrk工具对比了下二者的性能, Rust版本的还是比较快. 当然Golang版本使用的是同步的逻辑, 如果使用Goroutine请求数据库, 可能也会很快.\nGohugo时期 服务器还有几个月就要到期了, 一想到又要配置Mysql, Redis, 以及未完成的elasticsearch搜索, 评论功能等, 就有点头大. 虽说用docker可以解决, 但是还有什么比静态网站更省心呢\u0026hellip;\n静态网站生成器的选择 这个没做太多比较, 了解到有Hexo, Gohugo, Rust Zola等等. Gohugo各方面都满足我需求, 就选了这个\nHugo theme的选择 静态网站的话, theme应该是最重要的选择了. 列举了一下自己需要的功能:\n 首页列表简洁 支持明暗配色 支持分类/标签 文章支持显示目录 列表中的文章, 支持配图 最好支持搜索 最好支持手机浏览   比较了一些, 把范围缩小在zzo, even, jane, 最终选择了zzo(zzo还支持相册, 演示, 陈列柜, 出版物等功能, 有兴趣的同学可以研究下)\n评论系统的选择 本着纯静态的思想, 选择了utterances, 基于GitHub issues. 缺点是需要登录GitHub授权, 以及可能需要科学上网\n持续折腾中\u0026hellip; 最后, 希望自己和hxd同学能坚持写这个博客, 积少成多, 加油💪\n","description":"","id":15,"section":"posts","tags":["博客"],"title":"博客折腾记(持续更新)","uri":"https://blog.syzh.fun/posts/syzh/blog-system-change-updating/"},{"content":"随着公司的发展和项目的迭代，很多团队都维护者一个越来越庞大的前端项目群，其中可能有jquery项目，vue项目，react项目，如何更好的分割和整合项目，成为很多工程师的需求。参考后端微服务的概念，前端提出了微前端的方案。\nsingle-spa是其中比较有人气的，本文也是在基于学习这里的内容给出的总结。同时也研究了\n这里 的代码\n微前端的优势：\n 在同一页面上使用多个前端框架 而不用刷新页面 (React, AngularJS, Angular, Ember, 你正在使用的框架) 独立部署每一个单页面应用 新功能使用新框架，旧的单页应用不用重写可以共存 改善初始加载时间，延迟加载代码  在我理解来看，微前端主要满足用一个更好的调度框架，来调度各个不同项目在页面的展示的需求。\n例如 /#reactApp 就加载react项目，\n/#vueApp 就加载vue项目，路由切换可以卸载当前项目，切换新项目。说到底每个项目就是一个通过打包之后的bundle.js,也就是说路由切换可以加载不同的js进来，每个js都维护一个单页应用。\n在single-spa 中，每一个项目都是一个application,以下简称app,为了single-spa可以很好的调度各项目的加载，卸载流程，首先每个项目需要包装统一接口，\n1 2 3 4 5  const app1 = { bootstrap: () =\u0026gt; Promise.resolve(), //bootstrap function  mount: () =\u0026gt; Promise.resolve(), //mount function  unmount: () =\u0026gt; Promise.resolve(), //unmount function }   每个项目都有 bootstrap，mount,unmout 回调，其中回调返回promise,也可以包含一个数组，其中每一项都是返回promise的函数。promise 支持后面强大的链式调用，可以让single-spa将app 像管道一样筛选，加载，卸载。app回调函数会在single-spa合适的调度时机被调用。\n其中例如mount 回调中，不同的app可以分别执行自己的渲染,single-spa会传入参数，也就是说不同的app都需要调整自己的入口文件，满足app的回调才能嵌入这个更加灵活的整体\n1 2 3 4 5 6 7 8 9 10  export function mount(props) { return Promise .resolve() .then(() =\u0026gt; { // Do framework UI rendering here  // 这里可以分别调用react/vue 的渲染  console.log(\u0026#39;mounted!\u0026#39;) }); }   为了更加方便得控制app,分类app,手写微前端框架 提出了app的11个状态，每个状态对应一个app 在加载/启动/挂载/卸载 过程中的某个阶段，任何一个阶段出错了，状态都成为出错状态，不可逆。\n为了确保single-spa 处理路由在任何app之前，采用拦截window.addEventlistener 的方法，在拦截的方法里将hashchange|popstate 这连个事件存储起来，先不执行，默认只执行single-spa添加的hashchange|popstate，等到single-spa 控制流程结束，再依次触发（此时就是react-router、vue-router等绑定的事件）\n整个流程的核心在于single-spa 的核心流程，默认首先加载被注册的app，然后判断是否需要挂载/卸载app,如果浏览器或者手动触发了需要更改app,再依次执行卸载不需要的，挂载需要的app流程。此流程核心代码位于/my-single-spa/src/navigation/invoke.js\n","description":"","id":16,"section":"posts","tags":["前端"],"title":"微前端学习总结","uri":"https://blog.syzh.fun/posts/hxd/micro-front-end/"},{"content":"mac app   快捷启动: alfred\n alfred基本算是mac必备app了, 主要用到的功能如下  快捷启动 文件搜索 snippets短语扩展 计算器 字典 密码管理1password   workflows  颜色色值相关转换: Colors v2.0.2 时间格式相关转换: Datetime Format Converter 编解码: Encode / Decode v1.8.0 快捷打开项目: JetBrains - Open project 命令用法速查: tldr uuid生成器: uuid generator      数据库连接: sequel pro\n 虽然已经基本停止开发了, 也尝试过其他诸如datagrip, 不过不习惯, 又换回来了    备份: mac自带的time machine\n  gif录屏: licecap\n  pdf阅读器: skim/pdfelement, 后者备用\n  任务管理: omniFocus\n  视频播放器: iina\n  键盘自定义映射: karabiner\n 把长按enter映射为ctrl, 点击capslock映射为esc, 长按capslock映射为ctrl等等 更多复杂映射, 比如emacs专用映射等等, 可以在这里找到    系统指标监视器: istat menus\n 在菜单栏显示上下行流量, cpu温度, cpu使用率等等    终端: iterm\n  密码管理: 1password\n  清理键盘辅助工具: KeyboardCleanTool\n  文本编辑器: sublime/vscode\n  工作休息提醒: stretchly\n  浏览图片: xnviewMP\n  文件同步: dropbox\n  抓包: charles\n  菜单栏图标管理: bartender\n  自动切换壁纸: irvue\n  思维导图: scapple\n  听歌: spotify + telegram\n telegram的vk music bot机器人可以搜索并下载各种歌曲, 而且自带的音乐播放功能还不错\u0026hellip;    markdown编辑器: typora + ipic\n typora可以支持很多$\\LaTeX$公式符号等等 ipic可以帮助typora自动上传图片    命令行工具  包管理器: homebrew http客户端: httpie git diff增强: diff-so-fancy 文件查找(替代find): fd shell: fish 命令历史查找: fzf 文件内容搜索(替代grep): ripgrep  各种ide/编辑器配色方案: dracula 在线latex编辑器: overleaf ","description":"","id":17,"section":"posts","tags":["MacOS"],"title":"记录一下mac里装的应用","uri":"https://blog.syzh.fun/posts/syzh/my-mac-app/"},{"content":"小站的评论系统使用了utterances, 基于GitHub issues, 因此可能需要科学上网支持\n不方便的同学, 欢迎通过每篇博文底部的作者邮箱或Github账号与我们联系\n","description":"Hugo, the world’s fastest framework for building websites","id":22,"section":"","tags":null,"title":"About","uri":"https://blog.syzh.fun/about/"}]