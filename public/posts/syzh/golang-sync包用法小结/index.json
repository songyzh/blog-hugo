[{"content":"  程序执行到defer语句的时候, 被defer的函数的实参会在此时被求值\n  1 2 3 4 5 6 7 8 9 10  func a() { i := 0 // 被defer的函数实参会在此时被求值, 这里为0  defer fmt.Println(i) // i自增, 但不会影响defer的函数  i++ return } //===========输出=========== 0       被defer的函数调用, 执行顺序是\u0026quot;后进先出\u0026rdquo;\n  defer的函数调用会被压入一个栈中。当外层函数返回时，被推迟的函数会按照后进先出的顺序调用。\n  如果函数的返回值是命名的, defer语句中的函数可以读取或修改该值\n  1 2 3 4 5 6 7 8 9  // 修改命名的返回值 func c() (i int) { // 在defer语句中自增  defer func() { i++ }() // 这里i被设为1  return 1 } //=============输出============ 2     1 2 3 4 5 6 7 8  // 返回值是匿名的, 无法被defer修改 func c() int { i := 1 defer func() { i++ }() return i } //=============输出============ 1       实参估值和修改返回变量的例子\n  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  func test() (x int) { // defer语句的实参会被立刻估值, 因此实参x==0  defer func(n int) { // 实参x估值为0, 因此形参n==0  fmt.Printf(\u0026#34;in defer x as parameter: x = %d\\n\u0026#34;, n) // 这里的x是外面的x, 因此为9  fmt.Printf(\u0026#34;in defer x after return: x = %d\\n\u0026#34;, x) }(x) x = 7 // x==9  return 9 } // =============执行结果============== in defer x as parameter: x = 0 in defer x after return: x = 9       最好在获取资源之后, 立刻调用defer\n  defer在其所在的函数的末尾执行, 因此在for循环中使用时要注意\n  1 2 3 4 5 6 7 8 9 10  // 有问题的写法 for _, filename := range filenames { f, err := os.Open(filename) if err != nil { return err } // 释放资源的操作直到所在函数末尾才执行, 如果文件很多, 可能导致文件描述符用尽  defer f.Close() // 处理文件 }     1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  // 改进写法 for _, filename := range filenames { if err := doFile(filename); err != nil { return err } } // 抽取处理单个文件的逻辑, 此函数返回时即可关闭文件 func doFile(filename string) error { f, err := os.Open(filename) if err != nil { return err } defer f.Close() // 处理文件 }       ","description":"","id":2,"section":"posts","tags":["后端","Golang"],"title":"Golang defer语句用法小结","uri":"https://blog.syzh.fun/posts/syzh/golang-defer%E8%AF%AD%E5%8F%A5%E7%94%A8%E6%B3%95%E5%B0%8F%E7%BB%93/"},{"content":"  sync包提供传统的内存访问的同步机制\n  WaitGroup\n  等待若干goroutine执行完毕\n  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33  // 注意: 如果wg是在闭包环境中使用, 由于闭包中捕获的是变量本身, 因此直接使用wg变量即可. 但如果是下面代码这样, 作为函数的参数调用, 则需要传引用来保证使用的是同一个wg  // 传入公用的wg对象 hello := func(wg *sync.WaitGroup, id int) { // 执行完成后, 内部值-1  defer wg.Done() fmt.Printf(\u0026#34;Hello from %v!\\n\u0026#34;, id) } // 定义goroutine数量 const numGreeters = 5 // 初始化waitgroup var wg sync.WaitGroup // 一次性增加内部值, 也可以在for语句中逐个增加 wg.Add(numGreeters) for i := 0; i \u0026lt; numGreeters; i++ { // wg.Add(1) 如果使用逐个增加的方式  go hello(\u0026amp;wg, i+1) } // 阻塞, 直到内部值变为0 wg.Wait() //===========输出=============== // 顺序不确定 Hello from 1! Hello from 5! Hello from 2! Hello from 3! Hello from 4!       Mutex and RWMutex\n  保护关键区域(guard critical sections)\n  Mutex\n  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  var count int var lock sync.Mutex // 下面两个函数都是线程安全的 increment := func() { lock.Lock() // 使用defer, 确保锁被释放  defer lock.Unlock() count++ fmt.Printf(\u0026#34;Incrementing: %d\\n\u0026#34;, count) } decrement := func() { lock.Lock() defer lock.Unlock() count-- fmt.Printf(\u0026#34;Decrementing: %d\\n\u0026#34;, count) }       RWMutex\n  可以同时有任意多个读锁, 或一个写锁\n  读锁是共享的, 写锁是排他的\n  1 2 3 4 5 6 7 8 9 10 11 12 13 14  var mu sync.RWMutex var balance int func Balance() int { mu.RLock() // readers/shared lock  defer mu.RUnlock() return balance } func Deposit(amount int) { mu.Lock() // // writer/exclusive lock  defer mu.Unlock() balance += amount }         Cond\n  在某个点等待某事件(event)的发生, 在此之前保持阻塞/挂起状态, 使其他goroutine可以执行\n  用于notify的方法\n Signal: 通知等待最久的goroutine, 这个功能也可以用channel实现  runtime维护了一个FIFO保存等待通知的goroutine, 因此会通知等待最久的goroutine   Broadcast: 通知所有goroutine, 这个功能用channel不好实现    性能比使用channel实现好很多\n  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38  // 假设我们有一个固定len为2的queue, 我们想加入10个元素进去. 我们希望queue一有多余的空间, 就能通知我们, 让我们插入新的元素  // 创建一个cond, 需要传入一个sync.Locker来保护关键区域 c := sync.NewCond(\u0026amp;sync.Mutex{}) // 初始化queue queue := make([]interface{}, 0, 10) // dequeue函数 removeFromQueue := func(delay time.Duration) { // sleep delay的时间  time.Sleep(delay) // 使用lock保护关键区域  c.L.Lock() // dequeue  queue = queue[1:] fmt.Println(\u0026#34;Removed from queue\u0026#34;) // unlock, 离开关键区域  c.L.Unlock() // 通知等待最久的goroutine, 也可以用broadcast来通知所有  c.Signal() } for i := 0; i \u0026lt; 10; i++ { // 进入关键区域  c.L.Lock() // 需要使用for循环来检查条件. 因为接到通知并不一定意味着我们在等待的事情已经发生, 所以需要再次检查条件  for len(queue) == 2 { // 在内部会先调用unlock, 然后等待. 接到通知继续执行后, 会调用lock  c.Wait() } fmt.Println(\u0026#34;Adding to queue\u0026#34;) // enqueue  queue = append(queue, struct{}{}) // 启动goroutine, 1s后执行dequeue  go removeFromQueue(1 * time.Second) // 离开关键区域  c.L.Unlock() }       Once\n  每个sync.Once的对象, 只能调用1次Do方法, 之后的对Do的调用无效.\n  1 2 3 4 5 6 7 8 9 10 11 12  var count int increment := func() { count++ } decrement := func() { count-- } var once sync.Once // 第一次调用Do方法, 有效 once.Do(increment) // 此次调用Do方法无效 once.Do(decrement) fmt.Printf(\u0026#34;Count: %d\\n\u0026#34;, count) // count为1, once对象只能执行一次DO方法       Pool\n  创建一个对象池, 其中的对象可以复用(比如数据库连接), 且是线程安全的\n  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  myPool := \u0026amp;sync.Pool{ // 生成新对象  New: func() interface{} { fmt.Println(\u0026#34;Creating new instance.\u0026#34;) return struct{}{} }, } // pool是空的, 因此会创建新对象 myPool.Get() // 上面创建的对象没有被放回, 因此现在pool中还是空的 // 由于pool是空的, 因此会创建新对象 instance := myPool.Get() // 放回对象, 经常配合defer使用 myPool.Put(instance) // 由于pool中有对象, 因此不会创建新对象 myPool.Get() //============输出============ Creating new instance. Creating new instance.       ","description":"","id":3,"section":"posts","tags":["后端","Golang","GoSync"],"title":"Golang sync包用法小结","uri":"https://blog.syzh.fun/posts/syzh/golang-sync%E5%8C%85%E7%94%A8%E6%B3%95%E5%B0%8F%E7%BB%93/"},{"content":"提供了Golang交替打印的几个思路: 使用Goroutine, sync包中的WaitGroup和Cond\n  使用unbuffered channel实现\n  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36  func PrintABUnbufferedChannel() { // 使用2个channel实现交替运行  c1 := make(chan struct{}) c2 := make(chan struct{}) // 打印aaa的函数, 对2个channel执行send操作  PrintA := func() { for { c1 \u0026lt;- struct{}{} fmt.Println(\u0026#34;aaa\u0026#34;) time.Sleep(1 * time.Second) c2 \u0026lt;- struct{}{} } } // 打印bbb的函数, 对2个channel执行receive操作  PrintB := func() { for { \u0026lt;-c2 fmt.Println(\u0026#34;bbb\u0026#34;) time.Sleep(1 * time.Second) \u0026lt;-c1 } } // 先打印aaa  go func() { \u0026lt;-c1 }() go PrintA() go PrintB() time.Sleep(1 * time.Hour) }       使用sync.Cond配合sync.WaitGroup实现\n  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54  func PrintABCond() { // 使用2个cond实现交替运行  c1 := sync.NewCond(\u0026amp;sync.Mutex{}) c2 := sync.NewCond(\u0026amp;sync.Mutex{}) // 使用waitgroup协调顺序, 确保printA, printB先启动, 再发送第一个signal  var wg sync.WaitGroup // 打印aaa的函数, 等待c1, 通知c2  printA := func() { // 确保printA启动早于第一个signal  wg.Done() for { c1.L.Lock() // 等待信号  c1.Wait() fmt.Println(\u0026#34;aaa\u0026#34;) time.Sleep(1 * time.Second) // 发送信号  c2.Signal() c1.L.Unlock() } } // 打印bbb的函数, 等待c2, 通知c1  printB := func() { // 确保printB启动早于第一个signal  wg.Done() for { c2.L.Lock() // 等待信号  c2.Wait() fmt.Println(\u0026#34;bbb\u0026#34;) time.Sleep(1 * time.Second) // 发送信号  c1.Signal() c2.L.Unlock() } } wg.Add(2) // 先打印aaa  go func() { // 等待printA, printB启动后, 再发送第一个signal  wg.Wait() c1.Signal() }() go printA() go printB() time.Sleep(1 * time.Hour) }       使用for-select语句实现, 与方法1类似\n  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  func PrintABForSelect() { c1 := make(chan struct{}) c2 := make(chan struct{}) printAB := func() { for { select { case \u0026lt;-c1: fmt.Println(\u0026#34;aaa\u0026#34;) time.Sleep(1 * time.Second) c2 \u0026lt;- struct{}{} case \u0026lt;-c2: fmt.Println(\u0026#34;bbb\u0026#34;) time.Sleep(1 * time.Second) c1 \u0026lt;- struct{}{} } } } go func() { c1 \u0026lt;- struct{}{} }() go printAB() go printAB() time.Sleep(1 * time.Hour) }       ","description":"","id":4,"section":"posts","tags":["后端","Golang","Goroutine","GoChannel","GoSync"],"title":"Golang交替打印的几种实现方式","uri":"https://blog.syzh.fun/posts/syzh/golang%E4%BA%A4%E6%9B%BF%E6%89%93%E5%8D%B0%E7%9A%84%E5%87%A0%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F/"},{"content":"三色标记-清除算法(tricolor mark-and-sweep algorithm)\n 把heap中的对象, 用黑色, 灰色, 白色进行标记  黑色对象: 已经以其为root执行过可达性分析的对象 灰色对象: 需要但还未以其为root执行过可达性分析的对象 白色对象: 从gc root无法被触达的对象, 可能被垃圾回收   垃圾回收过程  垃圾回收开始时, 所有对象都是白色. 所有root对象被标记为灰色. root对象指程序可以直接访问的对象, 包含全局变量, 位于栈上的数据. 垃圾回收器选择一个灰色对象, 把它标记为黑色, 寻找其可以触达的白色对象, 并把它们标记为灰色. 直到把所有灰色对象都处理过一遍 此时的白色对象说明无法被触达, 因此可以被垃圾回收 如果在垃圾回收过程中, 某个灰色对象变得不可触达了, 则它会在下次垃圾回收时被清理   标记过程中, 执行中的应用程序被称为mutator, mutator有一个函数write barrier. 当heap中的某个对象被修改了, 说明该对象可被触达, 则write barrier会把此对象标记为灰色 当某channel无法被触达时, 即使其未被close, 也会被垃圾回收, 清理其占用的资源 手动触发GC: runtime.GC(), 此操作会阻塞调用者, 并可能阻塞整个程序 mark阶段, 标记对象; 没有灰色对象后, 开始sweep阶段 go的垃圾回收是与其他goroutine并发执行的  ","description":"","id":5,"section":"posts","tags":["后端","Golang","垃圾回收"],"title":"Golang垃圾回收-三色算法概览","uri":"https://blog.syzh.fun/posts/syzh/golang%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6-%E4%B8%89%E8%89%B2%E7%AE%97%E6%B3%95%E6%A6%82%E8%A7%88/"},{"content":"  问题表现\n  使用下标获取字符串的字符时, 可能得到奇怪的字符\n  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  func main() { s := \u0026#34;hello\u0026#34; fmt.Printf(\u0026#34;%c\\n\u0026#34;, s[1]) s = \u0026#34;你好\u0026#34; fmt.Printf(\u0026#34;%c\\n\u0026#34;, s[1]) } //============输出===========  e ½       问题原因\n golang是以utf8格式保存字符串的, 字符串的下标操作, 访问的是字节, 而不是字符. len函数输出的也是字节数, 如len(\u0026quot;hello\u0026quot;)==5, len(\u0026quot;你好\u0026quot;)==6    避免方式\n  把字符串转化为[]rune/[]int32, 或者使用range遍历\n  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  func main() { s := \u0026#34;你好\u0026#34; // 强转为[]rune  fmt.Printf(\u0026#34;%c\\n\u0026#34;, []rune(s)[1]) fmt.Println() // 使用range遍历  for _, c := range s { fmt.Printf(\u0026#34;%c\\n\u0026#34;, c) } } //===============输出=================  好 你 好       ","description":"","id":6,"section":"posts","tags":["后端","Golang","踩坑"],"title":"Golang踩坑总结-使用下标获取字符串的字符","uri":"https://blog.syzh.fun/posts/syzh/golang%E8%B8%A9%E5%9D%91%E6%80%BB%E7%BB%93-%E4%BD%BF%E7%94%A8%E4%B8%8B%E6%A0%87%E8%8E%B7%E5%8F%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%AD%97%E7%AC%A6/"},{"content":"  问题表现\n  goroutine中捕获的循环变量, 都为循环最后的值\n  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  func main() { for i, v := range []string{\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;, \u0026#34;d\u0026#34;, \u0026#34;e\u0026#34;} { // goroutine中捕获循环变量  go func() { fmt.Printf(\u0026#34;index: %v, value: %v\\n\u0026#34;, i, v) }() } // 此处应该使用workgroup实现, 为了简单使用了sleep  time.Sleep(1 * time.Second) } //================输出==============  index: 4, value: e index: 4, value: e index: 4, value: e index: 4, value: e index: 4, value: e       问题原因\n goroutine中捕获的不是\u0026quot;值\u0026rdquo;, 而是\u0026quot;有地址的变量\u0026rdquo;. for循环可能会先结束, 之后各个goroutine才开始执行. 因此得到的是变量的最终值    避免方式\n  在goroutine启动的函数中, 把变量作为参数捕获\n  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  func main() { for i, v := range []string{\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;, \u0026#34;d\u0026#34;, \u0026#34;e\u0026#34;} { // 把循环变量作为参数传入  go func(i int, v string) { // i, v是函数内部的局部变量  fmt.Printf(\u0026#34;index: %v, value: %v\\n\u0026#34;, i, v) }(i, v) } time.Sleep(1 * time.Second) } //================输出==============  index: 0, value: a index: 1, value: b index: 4, value: e index: 3, value: d index: 2, value: c       ","description":"","id":7,"section":"posts","tags":["后端","Golang","踩坑","Goroutine"],"title":"Golang踩坑总结-循环中使用Goroutine中捕获参数","uri":"https://blog.syzh.fun/posts/syzh/golang%E8%B8%A9%E5%9D%91%E6%80%BB%E7%BB%93-%E5%BE%AA%E7%8E%AF%E4%B8%AD%E4%BD%BF%E7%94%A8goroutine%E4%B8%AD%E6%8D%95%E8%8E%B7%E5%8F%82%E6%95%B0/"},{"content":"  问题表现\n  闭包中捕获的循环变量, 都为循环最后的值\n  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  func main() { // 保存函数闭包  var s []func() for i, v := range []string{\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;, \u0026#34;d\u0026#34;, \u0026#34;e\u0026#34;} { s = append(s, func() { // 捕获i, v, 保存在闭包中  fmt.Printf(\u0026#34;index: %v, value: %v\\n\u0026#34;, i, v) }) } for _, f := range s { f() } } // ====================输出===========================  index: 4, value: e index: 4, value: e index: 4, value: e index: 4, value: e index: 4, value: e       问题原因\n 闭包中捕获的不是\u0026quot;值\u0026rdquo;, 而是\u0026quot;有地址的变量\u0026rdquo;. 最终执行时, 根据变量寻址, 得到的是变量最后的值    避免方式\n  在循环中, 重新声明要捕获的变量. 由于是单个循环的局部变量, 在其作用域结束前, 会进行evaluate\n  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  func main() { // 保存函数闭包  var s []func() for i, v := range []string{\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;, \u0026#34;d\u0026#34;, \u0026#34;e\u0026#34;} { // 重新声明要捕获的变量  i, v := i, v s = append(s, func() { // 捕获i, v, 保存在闭包中  fmt.Printf(\u0026#34;index: %v, value: %v\\n\u0026#34;, i, v) }) } for _, f := range s { f() } } // ====================输出===========================  index: 0, value: a index: 1, value: b index: 2, value: c index: 3, value: d index: 4, value: e       ","description":"","id":8,"section":"posts","tags":["后端","Golang","踩坑","闭包"],"title":"Golang踩坑总结-循环中使用闭包捕获参数","uri":"https://blog.syzh.fun/posts/syzh/golang%E8%B8%A9%E5%9D%91%E6%80%BB%E7%BB%93-%E5%BE%AA%E7%8E%AF%E4%B8%AD%E4%BD%BF%E7%94%A8%E9%97%AD%E5%8C%85%E6%8D%95%E8%8E%B7%E5%8F%82%E6%95%B0/"},{"content":"  问题表现\n  具体类型的nil值, 赋值给接口值变量后, 被判定不为nil\n  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  func main() { // *bytes.Buffer, 零值为nil  var b *bytes.Buffer if b == nil { fmt.Println(\u0026#34;外面的b等于nil\u0026#34;) } else { fmt.Println(\u0026#34;外面的b不等于nil\u0026#34;) } f := func(b io.Writer) { if b == nil { fmt.Println(\u0026#34;里面的b等于nil\u0026#34;) } else { fmt.Println(\u0026#34;里面的b不等于nil\u0026#34;) } } // 把b传入函数  f(b) } //===========输出===============  外面的b等于nil 里面的b不等于nil       问题原因\n golang中的接口值, 除了有自己的类型type外, 还有动态类型(dynamic type)和动态值(dynamic value). 接口值如果要被判断为nil, 需要动态类型和动态值都为nil. 可以通过fmt的\u0026rdquo;%T\u0026rdquo;, \u0026ldquo;%v\u0026quot;观察动态类型和动态值    打印动态类型和动态值\n  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38  func main() { var b *bytes.Buffer fmt.Printf(\u0026#34;外面的b类型为%T\\n\u0026#34;, b) fmt.Printf(\u0026#34;外面的b值为%v\\n\u0026#34;, b) if b == nil { fmt.Println(\u0026#34;外面的b等于nil\u0026#34;) } else { fmt.Println(\u0026#34;外面的b不等于nil\u0026#34;) } fmt.Println(\u0026#34;\u0026#34;) f := func(b io.Writer) { fmt.Printf(\u0026#34;里面的b类型为%T\\n\u0026#34;, b) fmt.Printf(\u0026#34;里面的b值为%v\\n\u0026#34;, b) if b == nil { fmt.Println(\u0026#34;里面的b等于nil\u0026#34;) } else { fmt.Println(\u0026#34;里面的b不等于nil\u0026#34;) } } f(b) } //==============输出=================  外面的b类型为*bytes.Buffer 外面的b值为\u0026lt;nil\u0026gt; 外面的b等于nil 里面的b类型为*bytes.Buffer 里面的b值为\u0026lt;nil\u0026gt; 里面的b不等于nil       ","description":"","id":9,"section":"posts","tags":["后端","Golang","踩坑"],"title":"Golang踩坑总结-接口值是否等于nil","uri":"https://blog.syzh.fun/posts/syzh/golang%E8%B8%A9%E5%9D%91%E6%80%BB%E7%BB%93-%E6%8E%A5%E5%8F%A3%E5%80%BC%E6%98%AF%E5%90%A6%E7%AD%89%E4%BA%8Enil/"},{"content":"最近在用Golang搭建博客后端时, 遇到一个问题: 数据在从mysql到接口输出的json转化中, 需要做字段映射. 常规的方法是写db tag和json tag, 自动进行转换. 这种方式有点麻烦, 尤其struct和字段多起来的时候. 我的场景是mysql字段为snake_case, struct为CamelCase, json字段为snake_case, 就想着用代码来完成转换\n代码示例如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46  // 博客文章struct type Post struct { Content string Cover string CreatedAt time.Time FamilyID int ID int Slug string Status int Title string UpdatedAt time.Time } // struct和json互转 var keyMatchRegex = regexp.MustCompile(`\u0026#34;\\w+\u0026#34;:`) var wordBarrierRegex = regexp.MustCompile(`([a-z])([A-Z])`) // 重写Response类型的MarshalJSON方法 func (resp Response) MarshalJSON() ([]byte, error) { // 创建此类型, 防止递归  type Response_ Response marshalled, err := json.Marshal(Response_(resp)) // 正则替换  converted := keyMatchRegex.ReplaceAllFunc( marshalled, func(match []byte) []byte { return bytes.ToLower(wordBarrierRegex.ReplaceAll( match, []byte(`${1}_${2}`), )) }, ) return converted, err } // struct和db字段互转 var DB *sqlx.DB func init(){ // 使用sqlx包与数据库交互  DB = sqlx.MustConnect(\u0026#34;mysql\u0026#34;, \u0026#34;db connection\u0026#34;) // 支持自定义MapperFunc, 使用strcase包中的ToSnake  DB.MapperFunc(strcase.ToSnake) DB = DB.Unsafe() }   ","description":"","id":10,"section":"posts","tags":["后端","Golang"],"title":"Golang避免使用struct tag","uri":"https://blog.syzh.fun/posts/syzh/golang%E9%81%BF%E5%85%8D%E4%BD%BF%E7%94%A8struct-tag/"},{"content":"js的继承总结 本质都是原型链，设置子类的prototype，应用的时候实例属性定义在实例上，通用方法定义在原型链上，达到较好的复用和扩展效果。 方法一 继承父类的实例 function Father() { this.property = true; // 实例属性 } Father.prototype.getFatherValue = function(){ return this.property; // 通用方法 } function Son(){ this.sonProperty = false; } Son.prototype = new Father();//继承 Son.prototype.getSonProperty = function(){ return this.sonProperty } var instance = new Son(); instance.getFatherValue() 方法二 object.create 此方法是《你不知道的js》所推荐的方法，已经被广泛使用，此方法可以避免 new Father() 有可能会带来的负面作用\nfunction Father() { this.property = true; // 实例属性 } Father.prototype.getFatherValue = function(){ console.log('father') return this.property; // 通用方法 } function Son(){ Father.apply(this,arguments) // 子类借用父类的构造方法 实现继承实例属性 } // 注意是 Father.prototype Son.prototype = Object.create(Father.prototype,{ constructor: { value: Father; // 弥补这种方法的不足 } }) // 或者添加一句 // Son.constructor = Father Son.prototype.getSonProperty = function(){ return this.sonProperty } var instance = new Son(); instance.getFatherValue() 方法三 es6 class 本质还是原型链的语法糖，但是对于面向对象开发友好\nclass Father { constructor(name) { this.name = name; // 增加到实例上 } // 这里声明的普通方法都添加到原型上 drink() { console.log('father drink') } } class Son extends Father { // 关键是extends constructor(name) { // 如果没有constructor 默认使用父类的 // 这里的super指向的是父类 默认里面的this就是子类 super(name); // Animal.call(this) } drink() { // super = Super.prototype 这个super不能单独打印 super.drink(); console.log('son drink') } } let son = new Son(); son.drink() // super 指向有两种可能 在constructor 和 static中指向的是父类 // 在子类的原型方法中指向的是父类原型 // 静态方法 就是通过类来调用的方法 方法四 Object.setPrototypeOf 原理 方法设置一个指定的对象的原型 ( 即, 内部[[Prototype]]属性），mdn 从性能考虑不建议 链接\n// 就是直接修改 __proto__ function Father() { this.property = true; // 实例属性 } Father.prototype.getFatherValue = function(){ console.log(123) return this.property; // 通用方法 } function Son(){ this.sonProperty = false; } Object.setPrototypeOf(Son.prototype,Father.prototype) Son.prototype.getSonProperty = function(){ return this.sonProperty } var instance = new Son(); instance.getFatherValue() ","description":"","id":11,"section":"posts","tags":["前端","JavaScript"],"title":"JavaScript的继承总结","uri":"https://blog.syzh.fun/posts/hxd/js%E7%9A%84%E7%BB%A7%E6%89%BF%E6%80%BB%E7%BB%93/"},{"content":"随着公司的发展和项目的迭代，很多团队都维护者一个越来越庞大的前端项目群，其中可能有jquery项目，vue项目，react项目，如何更好的分割和整合项目，成为很多工程师的需求。参考后端微服务的概念，前端提出了微前端的方案。\nsingle-spa是其中比较有人气的，本文也是在基于学习这里的内容给出的总结。同时也研究了\n这里 的代码\n微前端的优势：\n 在同一页面上使用多个前端框架 而不用刷新页面 (React, AngularJS, Angular, Ember, 你正在使用的框架) 独立部署每一个单页面应用 新功能使用新框架，旧的单页应用不用重写可以共存 改善初始加载时间，延迟加载代码  在我理解来看，微前端主要满足用一个更好的调度框架，来调度各个不同项目在页面的展示的需求。\n例如 /#reactApp 就加载react项目，\n/#vueApp 就加载vue项目，路由切换可以卸载当前项目，切换新项目。说到底每个项目就是一个通过打包之后的bundle.js,也就是说路由切换可以加载不同的js进来，每个js都维护一个单页应用。\n在single-spa 中，每一个项目都是一个application,以下简称app,为了single-spa可以很好的调度各项目的加载，卸载流程，首先每个项目需要包装统一接口，\n1 2 3 4 5  const app1 = { bootstrap: () =\u0026gt; Promise.resolve(), //bootstrap function  mount: () =\u0026gt; Promise.resolve(), //mount function  unmount: () =\u0026gt; Promise.resolve(), //unmount function }   每个项目都有 bootstrap，mount,unmout 回调，其中回调返回promise,也可以包含一个数组，其中每一项都是返回promise的函数。promise 支持后面强大的链式调用，可以让single-spa将app 像管道一样筛选，加载，卸载。app回调函数会在single-spa合适的调度时机被调用。\n其中例如mount 回调中，不同的app可以分别执行自己的渲染,single-spa会传入参数，也就是说不同的app都需要调整自己的入口文件，满足app的回调才能嵌入这个更加灵活的整体\n1 2 3 4 5 6 7 8 9 10  export function mount(props) { return Promise .resolve() .then(() =\u0026gt; { // Do framework UI rendering here  // 这里可以分别调用react/vue 的渲染  console.log(\u0026#39;mounted!\u0026#39;) }); }   为了更加方便得控制app,分类app,手写微前端框架 提出了app的11个状态，每个状态对应一个app 在加载/启动/挂载/卸载 过程中的某个阶段，任何一个阶段出错了，状态都成为出错状态，不可逆。\n为了确保single-spa 处理路由在任何app之前，采用拦截window.addEventlistener 的方法，在拦截的方法里将hashchange|popstate 这连个事件存储起来，先不执行，默认只执行single-spa添加的hashchange|popstate，等到single-spa 控制流程结束，再依次触发（此时就是react-router、vue-router等绑定的事件）\n整个流程的核心在于single-spa 的核心流程，默认首先加载被注册的app，然后判断是否需要挂载/卸载app,如果浏览器或者手动触发了需要更改app,再依次执行卸载不需要的，挂载需要的app流程。此流程核心代码位于/my-single-spa/src/navigation/invoke.js\n","description":"","id":12,"section":"posts","tags":["前端"],"title":"微前端学习总结","uri":"https://blog.syzh.fun/posts/hxd/%E5%BE%AE%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"},{"content":"  mac app\n  快捷启动: alfred\n alfred基本算是mac必备app了, 主要用到的功能如下  快捷启动 文件搜索 snippets短语扩展 计算器 字典 密码管理1password   workflows  颜色色值相关转换: Colors v2.0.2 时间格式相关转换: Datetime Format Converter 编解码: Encode / Decode v1.8.0 快捷打开项目: JetBrains - Open project 命令用法速查: tldr uuid生成器: uuid generator      数据库连接: sequel pro\n 虽然已经基本停止开发了, 也尝试过其他诸如datagrip, 不过不习惯, 又换回来了    备份: mac自带的time machine\n  gif录屏: licecap\n  pdf阅读器: skim/pdfelement, 后者备用\n  任务管理: omniFocus\n  视频播放器: iina\n  键盘自定义映射: karabiner\n 把长按enter映射为ctrl, 点击capslock映射为esc, 长按capslock映射为ctrl等等 更多复杂映射, 比如emacs专用映射等等, 可以在这里找到    系统指标监视器: istat menus\n 在菜单栏显示上下行流量, cpu温度, cpu使用率等等    终端: iterm\n  密码管理: 1password\n  清理键盘辅助工具: KeyboardCleanTool\n  文本编辑器: sublime/vscode\n  工作休息提醒: stretchly\n  浏览图片: xnviewMP\n  文件同步: dropbox\n  抓包: charles\n  菜单栏图标管理: bartender\n  自动切换壁纸: irvue\n  思维导图: scapple\n  听歌: spotify + telegram\n telegram的vk music bot机器人可以搜索并下载各种歌曲, 而且自带的音乐播放功能还不错\u0026hellip;    markdown编辑器: typora + ipic\n typora可以支持很多$\\LaTeX$公式符号等等 ipic可以帮助typora自动上传图片      命令行工具\n 包管理器: homebrew http客户端: httpie git diff增强: diff-so-fancy 文件查找(替代find): fd shell: fish 命令历史查找: fzf 文件内容搜索(替代grep): ripgrep    各种ide/编辑器配色方案: dracula\n  在线latex编辑器: overleaf\n  ","description":"","id":13,"section":"posts","tags":["MacOS"],"title":"记录一下mac里装的应用","uri":"https://blog.syzh.fun/posts/syzh/%E8%AE%B0%E5%BD%95%E4%B8%80%E4%B8%8Bmac%E9%87%8C%E8%A3%85%E7%9A%84%E5%BA%94%E7%94%A8/"},{"content":"Written in Go, Hugo is an open source static site generator available under the Apache Licence 2.0. Hugo supports TOML, YAML and JSON data file types, Markdown and HTML content files and uses shortcodes to add rich content. Other notable features are taxonomies, multilingual mode, image processing, custom output formats, HTML/CSS/JS minification and support for Sass SCSS workflows.\nHugo makes use of a variety of open source projects including:\n https://github.com/russross/blackfriday https://github.com/alecthomas/chroma https://github.com/muesli/smartcrop https://github.com/spf13/cobra https://github.com/spf13/viper  Hugo is ideal for blogs, corporate websites, creative portfolios, online magazines, single page applications or even a website with thousands of pages.\nHugo is for people who want to hand code their own website without worrying about setting up complicated runtimes, dependencies and databases.\nWebsites built with Hugo are extremelly fast, secure and can be deployed anywhere including, AWS, GitHub Pages, Heroku, Netlify and any other hosting provider.\nLearn more and contribute on GitHub.\n","description":"Hugo, the world’s fastest framework for building websites","id":18,"section":"","tags":null,"title":"About","uri":"https://blog.syzh.fun/about/"}]